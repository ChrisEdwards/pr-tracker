{"id":"prt-0ar","title":"Implement root cobra command","description":"## Task\nCreate the main CLI command using Cobra.\n\n## File: internal/cli/root.go\n\n## Implementation\n```go\npackage cli\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"time\"\n    \n    \"prt/internal/config\"\n    \"prt/internal/display\"\n    \"prt/internal/github\"\n    \"prt/internal/scanner\"\n    \"prt/internal/categorizer\"\n    \n    \"github.com/spf13/cobra\"\n)\n\nvar (\n    rootCmd = \u0026cobra.Command{\n        Use:   \"prt\",\n        Short: \"GitHub PR Tracker\",\n        Long: `PRT - GitHub PR Tracker\n\nAggregate and visualize GitHub Pull Request status across multiple\nlocal repositories. Highlights PRs requiring your attention and\nshows stacked PR relationships.`,\n        RunE: runPRT,\n    }\n    \n    // Flags\n    flagPath    string\n    flagFilter  string\n    flagGroup   string\n    flagDepth   int\n    flagJSON    bool\n    flagNoColor bool\n)\n\nfunc init() {\n    rootCmd.Flags().StringVarP(\u0026flagPath, \"path\", \"p\", \"\", \"Search path (overrides config)\")\n    rootCmd.Flags().StringVarP(\u0026flagFilter, \"filter\", \"f\", \"\", \"Filter repos by name pattern\")\n    rootCmd.Flags().StringVarP(\u0026flagGroup, \"group\", \"g\", \"\", \"Group by: project, author\")\n    rootCmd.Flags().IntVarP(\u0026flagDepth, \"depth\", \"d\", 0, \"Scan depth\")\n    rootCmd.Flags().BoolVar(\u0026flagJSON, \"json\", false, \"Output as JSON\")\n    rootCmd.Flags().BoolVar(\u0026flagNoColor, \"no-color\", false, \"Disable colored output\")\n}\n\nfunc Execute(version string) error {\n    rootCmd.Version = version\n    return rootCmd.Execute()\n}\n\nfunc runPRT(cmd *cobra.Command, args []string) error {\n    startTime := time.Now()\n    \n    // 1. Load config\n    flags := \u0026config.Flags{\n        Path:   flagPath,\n        Filter: flagFilter,\n        Group:  flagGroup,\n        Depth:  flagDepth,\n    }\n    \n    cfg, err := config.Load(flags)\n    if err != nil {\n        return fmt.Errorf(\"config error: %w\", err)\n    }\n    \n    // 2. Check if setup needed\n    if cfg.NeedsSetup() {\n        return runWizard(cfg)\n    }\n    \n    // 3. Validate config\n    if err := cfg.Validate(); err != nil {\n        return err\n    }\n    \n    // 4. Check gh CLI\n    ghClient := github.NewClient(github.DefaultRetryConfig)\n    if err := ghClient.Check(); err != nil {\n        return err\n    }\n    \n    // 5. Auto-detect username if needed\n    if cfg.GitHubUsername == \"\" {\n        user, err := ghClient.GetCurrentUser()\n        if err != nil {\n            return fmt.Errorf(\"cannot determine GitHub username: %w\", err)\n        }\n        cfg.GitHubUsername = user\n    }\n    \n    // 6. Scan for repositories\n    scnr, err := scanner.NewScanner(cfg.ScanDepth, cfg.IncludeRepos)\n    if err != nil {\n        return err\n    }\n    \n    repos, err := scnr.Scan(cfg)\n    if err != nil {\n        return fmt.Errorf(\"scan error: %w\", err)\n    }\n    \n    if len(repos) == 0 {\n        fmt.Println(\"No Git repositories found in configured paths.\")\n        return nil\n    }\n    \n    // 7. Fetch PRs\n    progress := display.NewProgressDisplay(len(repos))\n    github.FetchAllPRs(repos, ghClient, func(done, total int, repo *models.Repository) {\n        progress.Update(repo)\n    })\n    progress.Finish()\n    \n    // 8. Categorize\n    cat := categorizer.NewCategorizer()\n    result := cat.Categorize(repos, cfg, cfg.GitHubUsername)\n    result.ScanDuration = time.Since(startTime)\n    \n    // 9. Render output\n    output, err := display.Render(result, display.RenderOptions{\n        ShowIcons:    cfg.ShowIcons,\n        ShowBranches: cfg.ShowBranchName,\n        NoColor:      flagNoColor,\n        JSON:         flagJSON,\n    })\n    if err != nil {\n        return err\n    }\n    \n    fmt.Print(output)\n    return nil\n}\n```\n\n## Acceptance Criteria\n- [ ] Command parses all flags\n- [ ] Full execution flow works\n- [ ] Config loaded correctly\n- [ ] Wizard triggered when needed\n- [ ] Output rendered\n\n## Part of Epic\nCLI Implementation (prt-3rn)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-19T10:46:22.800957-05:00","updated_at":"2025-12-19T10:46:22.800957-05:00","dependencies":[{"issue_id":"prt-0ar","depends_on_id":"prt-e31","type":"blocks","created_at":"2025-12-19T10:50:30.997614-05:00","created_by":"daemon"},{"issue_id":"prt-0ar","depends_on_id":"prt-tsv","type":"blocks","created_at":"2025-12-19T10:50:31.580052-05:00","created_by":"daemon"},{"issue_id":"prt-0ar","depends_on_id":"prt-uym","type":"blocks","created_at":"2025-12-19T10:50:32.126685-05:00","created_by":"daemon"},{"issue_id":"prt-0ar","depends_on_id":"prt-2f2","type":"blocks","created_at":"2025-12-19T10:50:32.731518-05:00","created_by":"daemon"},{"issue_id":"prt-0ar","depends_on_id":"prt-3rn","type":"parent-child","created_at":"2025-12-19T11:01:53.861046-05:00","created_by":"daemon"}]}
{"id":"prt-0ch","title":"Implement config file template generation","description":"## Task\nGenerate a well-commented YAML config file template for new users.\n\n## File: internal/config/config.go (add to existing)\n\n## Template\n```go\nconst configTemplate = `# PRT Configuration\n# https://github.com/ChrisEdwards/prt\n\n# Your GitHub username (required)\n# Used to identify PRs you authored and review requests for you\n# Auto-detected if left empty (via \\`gh api user\\`)\ngithub_username: \"{{.GitHubUsername}}\"\n\n# Team members (GitHub usernames)\n# PRs from these users are highlighted as \"Team PRs\"\nteam_members:\n{{- range .TeamMembers}}\n  - \"{{.}}\"\n{{- else}}\n  # - \"teammate1\"\n  # - \"teammate2\"\n{{- end}}\n\n# Directories to search for Git repositories\n# Supports absolute paths and ~ for home directory\nsearch_paths:\n{{- range .SearchPaths}}\n  - \"{{.}}\"\n{{- else}}\n  # - \"~/code/work\"\n  # - \"~/projects\"\n{{- end}}\n\n# Repository name patterns to include (glob syntax)\n# Leave empty to include all discovered repositories\n# Examples: \"myorg-*\", \"*-api\", \"frontend\"\ninclude_repos:\n{{- range .IncludeRepos}}\n  - \"{{.}}\"\n{{- else}}\n  # - \"myorg-*\"\n{{- end}}\n\n# Maximum directory depth when searching for repositories\n# Default: 3\nscan_depth: {{.ScanDepth}}\n\n# Known bot accounts (PRs from these are de-prioritized)\n# Pre-populated with common bots; add your org's bots here\nbots:\n{{- range .Bots}}\n  - \"{{.}}\"\n{{- end}}\n\n# Default grouping: \"project\" or \"author\"\ndefault_group_by: \"{{.DefaultGroupBy}}\"\n\n# Default sort order: \"oldest\" or \"newest\" (by creation date)\ndefault_sort: \"{{.DefaultSort}}\"\n\n# Show branch names in PR output\nshow_branch_name: {{.ShowBranchName}}\n\n# Show icons (requires a Nerd Font or emoji support)\nshow_icons: {{.ShowIcons}}\n`\n\nfunc GenerateConfigFile(cfg *Config) (string, error) {\n    tmpl, err := template.New(\"config\").Parse(configTemplate)\n    if err != nil {\n        return \"\", err\n    }\n    \n    var buf bytes.Buffer\n    if err := tmpl.Execute(\u0026buf, cfg); err != nil {\n        return \"\", err\n    }\n    \n    return buf.String(), nil\n}\n\nfunc SaveConfig(cfg *Config) error {\n    content, err := GenerateConfigFile(cfg)\n    if err != nil {\n        return err\n    }\n    \n    // Ensure directory exists\n    if err := os.MkdirAll(ConfigDir(), 0755); err != nil {\n        return err\n    }\n    \n    return os.WriteFile(ConfigPath(), []byte(content), 0644)\n}\n```\n\n## Why Template vs yaml.Marshal?\n- Templates allow comments (yaml.Marshal doesn't preserve comments)\n- Templates produce human-readable output with explanations\n- Users learn what each option does from the config itself\n\n## Acceptance Criteria\n- [ ] Template generates valid YAML\n- [ ] Comments explain each field\n- [ ] Default values shown correctly\n- [ ] Empty slices show commented examples\n- [ ] File saved with correct permissions (0644)\n- [ ] Directory created if missing\n\n## Part of Epic\nConfiguration System (prt-v3f)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-19T10:39:44.452751-05:00","updated_at":"2025-12-19T10:39:44.452751-05:00","dependencies":[{"issue_id":"prt-0ch","depends_on_id":"prt-5eu","type":"blocks","created_at":"2025-12-19T10:48:57.347063-05:00","created_by":"daemon"},{"issue_id":"prt-0ch","depends_on_id":"prt-v3f","type":"parent-child","created_at":"2025-12-19T11:01:06.383548-05:00","created_by":"daemon"}]}
{"id":"prt-0fv","title":"Implement setup wizard","description":"## Task\nCreate an interactive first-run setup wizard.\n\n## File: internal/cli/wizard.go\n\n## Wizard Flow\n```\nWelcome to PRT (PR Tracker)! üöÄ\n\nLet's set up your configuration.\n\n? What is your GitHub username? (leave blank to auto-detect)\n\u003e [user input]\n\n‚úì Detected username: jdoe\n\n? Where should PRT look for repositories?\n  (Enter paths separated by commas, ~ supported)\n\u003e [user input]\n\n? Add team members? (GitHub usernames, comma-separated)\n\u003e [user input]\n\nConfiguration saved to ~/.prt/config.yaml\n\nRun `prt` to see your PR dashboard!\n```\n\n## Implementation\n```go\npackage cli\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"strings\"\n    \n    \"prt/internal/config\"\n    \"prt/internal/github\"\n)\n\nfunc runWizard(cfg *config.Config) error {\n    reader := bufio.NewReader(os.Stdin)\n    \n    fmt.Println(\"Welcome to PRT (PR Tracker)! üöÄ\")\n    fmt.Println()\n    fmt.Println(\"Let's set up your configuration.\")\n    fmt.Println()\n    \n    // Username\n    fmt.Print(\"? What is your GitHub username? (leave blank to auto-detect)\\n\u003e \")\n    username, _ := reader.ReadString('\\n')\n    username = strings.TrimSpace(username)\n    \n    if username == \"\" {\n        // Try auto-detect\n        client := github.NewClient(github.DefaultRetryConfig)\n        detected, err := client.GetCurrentUser()\n        if err != nil {\n            fmt.Println(\"Could not auto-detect username. Please enter manually.\")\n            fmt.Print(\"\u003e \")\n            username, _ = reader.ReadString('\\n')\n            username = strings.TrimSpace(username)\n        } else {\n            username = detected\n            fmt.Printf(\"‚úì Detected username: %s\\n\\n\", username)\n        }\n    }\n    cfg.GitHubUsername = username\n    \n    // Search paths\n    fmt.Print(\"? Where should PRT look for repositories?\\n  (Enter paths separated by commas, ~ supported)\\n\u003e \")\n    pathsInput, _ := reader.ReadString('\\n')\n    pathsInput = strings.TrimSpace(pathsInput)\n    \n    if pathsInput != \"\" {\n        paths := strings.Split(pathsInput, \",\")\n        for i, p := range paths {\n            paths[i] = strings.TrimSpace(p)\n        }\n        cfg.SearchPaths = paths\n    }\n    \n    // Validate paths\n    for _, p := range cfg.SearchPaths {\n        expanded := expandPath(p)\n        if _, err := os.Stat(expanded); os.IsNotExist(err) {\n            fmt.Printf(\"‚ö† Warning: Path does not exist: %s\\n\", p)\n        }\n    }\n    fmt.Println()\n    \n    // Team members\n    fmt.Print(\"? Add team members? (GitHub usernames, comma-separated, blank to skip)\\n\u003e \")\n    teamInput, _ := reader.ReadString('\\n')\n    teamInput = strings.TrimSpace(teamInput)\n    \n    if teamInput != \"\" {\n        members := strings.Split(teamInput, \",\")\n        for i, m := range members {\n            members[i] = strings.TrimSpace(m)\n        }\n        cfg.TeamMembers = members\n        fmt.Printf(\"‚úì Added %d team members\\n\\n\", len(members))\n    }\n    \n    // Save config\n    if err := config.SaveConfig(cfg); err != nil {\n        return fmt.Errorf(\"failed to save config: %w\", err)\n    }\n    \n    fmt.Printf(\"Configuration saved to %s\\n\\n\", config.ConfigPath())\n    fmt.Println(\"Run \\ to see your PR dashboard!\")\n    \n    return nil\n}\n\nfunc expandPath(p string) string {\n    if strings.HasPrefix(p, \"~\") {\n        home, _ := os.UserHomeDir()\n        return filepath.Join(home, p[1:])\n    }\n    return p\n}\n```\n\n## Acceptance Criteria\n- [ ] Wizard runs on first launch\n- [ ] Username auto-detection works\n- [ ] Paths saved correctly\n- [ ] Team members saved\n- [ ] Config file created\n- [ ] Can re-run wizard\n\n## Part of Epic\nSetup Wizard (prt-bn4)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-19T10:46:23.745554-05:00","updated_at":"2025-12-19T10:46:23.745554-05:00","dependencies":[{"issue_id":"prt-0fv","depends_on_id":"prt-0ar","type":"blocks","created_at":"2025-12-19T10:50:36.150522-05:00","created_by":"daemon"},{"issue_id":"prt-0fv","depends_on_id":"prt-0ch","type":"blocks","created_at":"2025-12-19T10:50:36.687689-05:00","created_by":"daemon"},{"issue_id":"prt-0fv","depends_on_id":"prt-bn4","type":"parent-child","created_at":"2025-12-19T11:01:54.486122-05:00","created_by":"daemon"}]}
{"id":"prt-151","title":"Implement PR row rendering","description":"## Task\nRender individual PR details as formatted rows.\n\n## File: internal/display/renderer.go\n\n## PR Row Format\n```\n  ‚îú‚îÄ‚îÄ #402 Feature: Transformer Logic\n  ‚îÇ   Draft ¬∑ Created 4d ago ¬∑ CI ‚úÖ\n  ‚îÇ   feature/transformer ‚Üí main\n  ‚îÇ   https://github.com/org/repo/pull/402\n```\n\n## Implementation\n```go\nfunc RenderPR(pr *models.PR, prefix string, showIcons bool, showBranches bool, isBlocked bool) string {\n    var b strings.Builder\n    \n    // Line 1: Number and title\n    titleLine := fmt.Sprintf(\"%s #%d %s\", prefix, pr.Number, pr.Title)\n    if isBlocked {\n        titleLine = BlockedStyle.Render(titleLine)\n    }\n    b.WriteString(titleLine)\n    b.WriteString(\"\\n\")\n    \n    // Line 2: Status details\n    indent := strings.Repeat(\" \", len(prefix)+4)\n    b.WriteString(indent)\n    b.WriteString(formatStatusLine(pr, showIcons))\n    b.WriteString(\"\\n\")\n    \n    // Line 3: Branch info (optional)\n    if showBranches {\n        b.WriteString(indent)\n        if pr.Author != \"\" {\n            b.WriteString(MetaStyle.Render(fmt.Sprintf(\"@%s ¬∑ \", pr.Author)))\n        }\n        b.WriteString(MetaStyle.Render(fmt.Sprintf(\"%s ‚Üí %s\", pr.HeadBranch, pr.BaseBranch)))\n        b.WriteString(\"\\n\")\n    }\n    \n    // Line 4: URL\n    b.WriteString(indent)\n    b.WriteString(URLStyle.Render(pr.URL))\n    b.WriteString(\"\\n\")\n    \n    return b.String()\n}\n\nfunc formatStatusLine(pr *models.PR, showIcons bool) string {\n    var parts []string\n    \n    // State\n    state := formatState(pr, showIcons)\n    parts = append(parts, state)\n    \n    // Age\n    parts = append(parts, fmt.Sprintf(\"Created %s\", pr.AgeString()))\n    \n    // CI Status\n    ci := formatCIStatus(pr.CIStatus, showIcons)\n    parts = append(parts, ci)\n    \n    // Approvals (if any)\n    approvals := countApprovals(pr.Reviews)\n    if approvals \u003e 0 {\n        parts = append(parts, fmt.Sprintf(\"%d approval%s\", approvals, pluralize(approvals)))\n    }\n    \n    return MetaStyle.Render(strings.Join(parts, \" ¬∑ \"))\n}\n\nfunc formatState(pr *models.PR, showIcons bool) string {\n    switch pr.EffectiveState() {\n    case models.PRStateDraft:\n        if showIcons {\n            return DraftStyle.Render(IconDraft + \" Draft\")\n        }\n        return DraftStyle.Render(\"Draft\")\n    case models.PRStateOpen:\n        if showIcons {\n            return NeedsReviewStyle.Render(IconReview + \" Waiting review\")\n        }\n        return NeedsReviewStyle.Render(\"Waiting review\")\n    default:\n        return pr.State\n    }\n}\n\nfunc formatCIStatus(status models.CIStatus, showIcons bool) string {\n    switch status {\n    case models.CIStatusPassing:\n        if showIcons {\n            return CIPassingStyle.Render(\"CI \" + IconCIPassing)\n        }\n        return CIPassingStyle.Render(\"CI ‚úì\")\n    case models.CIStatusFailing:\n        if showIcons {\n            return CIFailingStyle.Render(\"CI \" + IconCIFailing)\n        }\n        return CIFailingStyle.Render(\"CI ‚úó\")\n    case models.CIStatusPending:\n        if showIcons {\n            return CIPendingStyle.Render(\"CI \" + IconCIPending)\n        }\n        return CIPendingStyle.Render(\"CI ...\")\n    default:\n        return \"\"\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] All PR fields rendered\n- [ ] States styled correctly\n- [ ] CI status colored\n- [ ] Blocked PRs dimmed\n- [ ] URLs formatted\n- [ ] Icons optional\n\n## Part of Epic\nDisplay System (prt-75i)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-19T10:45:15.499644-05:00","updated_at":"2025-12-19T10:45:15.499644-05:00","dependencies":[{"issue_id":"prt-151","depends_on_id":"prt-krw","type":"blocks","created_at":"2025-12-19T10:50:18.167492-05:00","created_by":"daemon"},{"issue_id":"prt-151","depends_on_id":"prt-jn5","type":"blocks","created_at":"2025-12-19T10:50:18.782139-05:00","created_by":"daemon"},{"issue_id":"prt-151","depends_on_id":"prt-75i","type":"parent-child","created_at":"2025-12-19T11:01:51.448465-05:00","created_by":"daemon"}]}
{"id":"prt-16a","title":"Define GitHub error types","description":"## Task\nDefine all error types for GitHub operations.\n\n## File: internal/github/errors.go\n\n## Error Types\n```go\npackage github\n\nimport \"fmt\"\n\n// GHNotFoundError indicates gh CLI is not installed\ntype GHNotFoundError struct {\n    Message string\n}\n\nfunc (e *GHNotFoundError) Error() string {\n    return e.Message\n}\n\n// GHAuthError indicates gh is not authenticated\ntype GHAuthError struct {\n    Message string\n}\n\nfunc (e *GHAuthError) Error() string {\n    return e.Message\n}\n\n// RepoScanError indicates a repository-specific failure\ntype RepoScanError struct {\n    RepoPath string\n    RepoName string\n    Cause    error\n}\n\nfunc (e *RepoScanError) Error() string {\n    return fmt.Sprintf(\"failed to scan %s: %v\", e.RepoName, e.Cause)\n}\n\nfunc (e *RepoScanError) Unwrap() error {\n    return e.Cause\n}\n\n// NetworkError indicates a network-related failure\ntype NetworkError struct {\n    Cause   error\n    Retries int\n}\n\nfunc (e *NetworkError) Error() string {\n    return fmt.Sprintf(\"network error after %d retries: %v\", e.Retries, e.Cause)\n}\n\nfunc (e *NetworkError) Unwrap() error {\n    return e.Cause\n}\n\n// RateLimitError indicates GitHub API rate limit was hit\ntype RateLimitError struct {\n    ResetTime time.Time\n}\n\nfunc (e *RateLimitError) Error() string {\n    if \\!e.ResetTime.IsZero() {\n        return fmt.Sprintf(\"GitHub API rate limit reached. Resets at %s\", e.ResetTime.Format(time.RFC822))\n    }\n    return \"GitHub API rate limit reached. Please wait and retry.\"\n}\n\n// RepoNotFoundError indicates the repo doesn't exist or user lacks access\ntype RepoNotFoundError struct {\n    RepoPath string\n}\n\nfunc (e *RepoNotFoundError) Error() string {\n    return fmt.Sprintf(\"repository not found or no access: %s\", e.RepoPath)\n}\n```\n\n## Error Classification Function\n```go\nfunc classifyError(err error, repoPath string) error {\n    if err == nil {\n        return nil\n    }\n    \n    // Get stderr if available\n    stderr := \"\"\n    if exitErr, ok := err.(*exec.ExitError); ok {\n        stderr = string(exitErr.Stderr)\n    }\n    \n    // Check for specific error patterns\n    if strings.Contains(stderr, \"rate limit\") {\n        return \u0026RateLimitError{}\n    }\n    \n    if strings.Contains(stderr, \"not found\") || strings.Contains(stderr, \"Could not resolve\") {\n        return \u0026RepoNotFoundError{RepoPath: repoPath}\n    }\n    \n    if strings.Contains(stderr, \"auth\") || strings.Contains(stderr, \"401\") {\n        return \u0026GHAuthError{Message: stderr}\n    }\n    \n    // Default to generic repo scan error\n    return \u0026RepoScanError{\n        RepoPath: repoPath,\n        Cause:    err,\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] All error types defined\n- [ ] Unwrap() implemented where appropriate\n- [ ] Error messages are clear\n- [ ] classifyError() handles common cases\n- [ ] Unit tests for error classification\n\n## Part of Epic\nGitHub CLI Integration (prt-749)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-19T10:41:23.729491-05:00","updated_at":"2025-12-19T10:41:23.729491-05:00","dependencies":[{"issue_id":"prt-16a","depends_on_id":"prt-mt5","type":"blocks","created_at":"2025-12-19T10:49:02.722265-05:00","created_by":"daemon"},{"issue_id":"prt-16a","depends_on_id":"prt-749","type":"parent-child","created_at":"2025-12-19T11:01:18.129705-05:00","created_by":"daemon"}]}
{"id":"prt-2f2","title":"Implement main output orchestrator","description":"## Task\nOrchestrate the complete terminal output from a ScanResult.\n\n## File: internal/display/renderer.go\n\n## Main Render Function\n```go\ntype RenderOptions struct {\n    ShowIcons    bool\n    ShowBranches bool\n    NoColor      bool\n    JSON         bool\n}\n\nfunc Render(result *models.ScanResult, opts RenderOptions) (string, error) {\n    if opts.JSON {\n        return RenderJSON(result)\n    }\n    \n    if opts.NoColor {\n        DisableColors()\n    }\n    \n    var b strings.Builder\n    \n    // Header\n    b.WriteString(renderHeader())\n    b.WriteString(\"\\n\\n\")\n    \n    // Sections\n    b.WriteString(RenderSection(\"MY PRS\", IconPR, result.MyPRs, result.Stacks, opts.ShowIcons, opts.ShowBranches))\n    b.WriteString(\"\\n\")\n    \n    b.WriteString(RenderSection(\"NEEDS MY ATTENTION\", IconReview, result.NeedsMyAttention, result.Stacks, opts.ShowIcons, opts.ShowBranches))\n    b.WriteString(\"\\n\")\n    \n    b.WriteString(RenderSection(\"TEAM PRS\", IconTeam, result.TeamPRs, result.Stacks, opts.ShowIcons, opts.ShowBranches))\n    b.WriteString(\"\\n\")\n    \n    b.WriteString(RenderSection(\"OTHER PRS\", IconBot, result.OtherPRs, result.Stacks, opts.ShowIcons, opts.ShowBranches))\n    b.WriteString(\"\\n\")\n    \n    // Repos without PRs\n    if len(result.ReposWithoutPRs) \u003e 0 {\n        b.WriteString(renderReposWithoutPRs(result.ReposWithoutPRs, opts.ShowIcons))\n        b.WriteString(\"\\n\")\n    }\n    \n    // Footer\n    b.WriteString(renderFooter(result))\n    \n    return b.String(), nil\n}\n\nfunc renderHeader() string {\n    return HeaderStyle.Render(\"PRT\") + \" \" + strings.Repeat(\"‚ïê\", 60)\n}\n\nfunc renderFooter(result *models.ScanResult) string {\n    duration := result.ScanDuration.Round(time.Millisecond * 100)\n    return MetaStyle.Render(fmt.Sprintf(\n        \"\\n%s\\nScanned %d repos ¬∑ Found %d PRs ¬∑ %s\",\n        strings.Repeat(\"‚ïê\", 65),\n        result.TotalReposScanned,\n        result.TotalPRsFound,\n        duration,\n    ))\n}\n\nfunc renderReposWithoutPRs(repos []*models.Repository, showIcons bool) string {\n    var b strings.Builder\n    \n    icon := \"\"\n    if showIcons {\n        icon = \"üìÇ \"\n    }\n    \n    b.WriteString(HeaderStyle.Render(icon + \"REPOS WITH NO OPEN PRS\"))\n    b.WriteString(\"\\n\\n\")\n    \n    for _, repo := range repos {\n        b.WriteString(fmt.Sprintf(\"  ‚Ä¢ %s (%s)\\n\", repo.Name, repo.Path))\n    }\n    \n    return b.String()\n}\n```\n\n## Acceptance Criteria\n- [ ] All sections rendered in order\n- [ ] Header and footer present\n- [ ] JSON mode works\n- [ ] No-color mode works\n- [ ] Icons toggleable\n- [ ] Branch names toggleable\n\n## Part of Epic\nDisplay System (prt-75i)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-19T10:45:18.444411-05:00","updated_at":"2025-12-19T10:45:18.444411-05:00","dependencies":[{"issue_id":"prt-2f2","depends_on_id":"prt-rcx","type":"blocks","created_at":"2025-12-19T10:50:25.937483-05:00","created_by":"daemon"},{"issue_id":"prt-2f2","depends_on_id":"prt-151","type":"blocks","created_at":"2025-12-19T10:50:26.485504-05:00","created_by":"daemon"},{"issue_id":"prt-2f2","depends_on_id":"prt-7mh","type":"blocks","created_at":"2025-12-19T10:50:27.13937-05:00","created_by":"daemon"},{"issue_id":"prt-2f2","depends_on_id":"prt-5un","type":"blocks","created_at":"2025-12-19T10:50:27.752728-05:00","created_by":"daemon"},{"issue_id":"prt-2f2","depends_on_id":"prt-75i","type":"parent-child","created_at":"2025-12-19T11:01:53.268969-05:00","created_by":"daemon"},{"issue_id":"prt-2f2","depends_on_id":"prt-krw","type":"blocks","created_at":"2025-12-19T11:08:57.800995-05:00","created_by":"daemon"}]}
{"id":"prt-2ll","title":"Implement gh CLI check","description":"## Task\nImplement checking for gh CLI availability and authentication status.\n\n## File: internal/github/client.go\n\n## Check Function\n```go\nfunc (c *client) Check() error {\n    // 1. Check gh exists\n    _, err := exec.LookPath(\"gh\")\n    if err != nil {\n        return \u0026GHNotFoundError{\n            Message: `GitHub CLI (gh) not found.\n\nPlease install it:\n  brew install gh\n\nThen authenticate:\n  gh auth login`,\n        }\n    }\n    \n    // 2. Check authentication\n    cmd := exec.Command(\"gh\", \"auth\", \"status\")\n    cmd.Stdout = io.Discard\n    cmd.Stderr = io.Discard\n    \n    if err := cmd.Run(); err != nil {\n        return \u0026GHAuthError{\n            Message: `GitHub CLI is not authenticated.\n\nPlease run:\n  gh auth login`,\n        }\n    }\n    \n    return nil\n}\n```\n\n## Error Types\nDefine in internal/github/errors.go:\n```go\ntype GHNotFoundError struct {\n    Message string\n}\n\nfunc (e *GHNotFoundError) Error() string {\n    return e.Message\n}\n\ntype GHAuthError struct {\n    Message string\n}\n\nfunc (e *GHAuthError) Error() string {\n    return e.Message\n}\n```\n\n## Why Separate Error Types?\nAllows callers to handle different errors differently:\n- GHNotFoundError: Prompt user to install\n- GHAuthError: Prompt user to authenticate\n\n## Acceptance Criteria\n- [ ] Detects missing gh CLI\n- [ ] Detects unauthenticated gh\n- [ ] Error messages include install/auth instructions\n- [ ] Unit tests with mocked exec\n\n## Part of Epic\nGitHub CLI Integration (prt-749)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-19T10:41:12.367457-05:00","updated_at":"2025-12-19T10:41:12.367457-05:00","dependencies":[{"issue_id":"prt-2ll","depends_on_id":"prt-16a","type":"blocks","created_at":"2025-12-19T10:49:03.297176-05:00","created_by":"daemon"},{"issue_id":"prt-2ll","depends_on_id":"prt-749","type":"parent-child","created_at":"2025-12-19T11:01:15.616595-05:00","created_by":"daemon"}]}
{"id":"prt-3by","title":"Implement progress display during fetch","description":"## Task\nDisplay a progress bar while fetching PRs from repositories.\n\n## File: internal/display/progress.go\n\n## Design\nUsing Bubble Tea for smooth progress updates:\n```\nScanning repositories...\n\n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 60% (3/5 repos)\n\n‚úì contrast-sdk (4 PRs)\n‚úì aiml-core (1 PR)\n‚úì aiml-tools (0 PRs)\n‚†ã contrast-cli...\n```\n\n## Simple Implementation (Alternative)\nFor simplicity, can use plain terminal output:\n```go\ntype ProgressDisplay struct {\n    total     int\n    done      int\n    results   []string\n    mu        sync.Mutex\n}\n\nfunc NewProgressDisplay(total int) *ProgressDisplay {\n    return \u0026ProgressDisplay{total: total}\n}\n\nfunc (p *ProgressDisplay) Update(repo *models.Repository) {\n    p.mu.Lock()\n    defer p.mu.Unlock()\n    \n    p.done++\n    \n    // Build result line\n    var line string\n    switch repo.ScanStatus {\n    case models.ScanStatusSuccess:\n        line = fmt.Sprintf(\"‚úì %s (%d PRs)\", repo.Name, len(repo.PRs))\n    case models.ScanStatusNoPRs:\n        line = fmt.Sprintf(\"‚úì %s (0 PRs)\", repo.Name)\n    case models.ScanStatusError:\n        line = fmt.Sprintf(\"‚úó %s (error)\", repo.Name)\n    }\n    \n    p.results = append(p.results, line)\n    \n    // Clear and redraw\n    p.render()\n}\n\nfunc (p *ProgressDisplay) render() {\n    // Clear previous output\n    fmt.Print(\"\\033[2J\\033[H\")\n    \n    // Progress bar\n    pct := float64(p.done) / float64(p.total)\n    barWidth := 40\n    filled := int(pct * float64(barWidth))\n    bar := strings.Repeat(\"‚ñà\", filled) + strings.Repeat(\"‚ñë\", barWidth-filled)\n    fmt.Printf(\"Scanning repositories...\\n\\n\")\n    fmt.Printf(\"%s %d%% (%d/%d)\\n\\n\", bar, int(pct*100), p.done, p.total)\n    \n    // Results\n    for _, r := range p.results {\n        fmt.Println(r)\n    }\n}\n```\n\n## Integration with Fetcher\n```go\nprogress := display.NewProgressDisplay(len(repos))\nFetchAllPRs(repos, client, func(done, total int, repo *Repository) {\n    progress.Update(repo)\n})\nprogress.Finish()\n```\n\n## Acceptance Criteria\n- [ ] Progress bar updates as repos complete\n- [ ] Shows completed repos with PR count\n- [ ] Shows errors for failed repos\n- [ ] Thread-safe (concurrent updates)\n- [ ] Clean final output\n\n## Part of Epic\nConcurrent PR Fetching \u0026 Orchestration (prt-e4a)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-19T10:43:57.511127-05:00","updated_at":"2025-12-19T10:43:57.511127-05:00","dependencies":[{"issue_id":"prt-3by","depends_on_id":"prt-mt5","type":"blocks","created_at":"2025-12-19T10:49:45.382112-05:00","created_by":"daemon"},{"issue_id":"prt-3by","depends_on_id":"prt-e4a","type":"parent-child","created_at":"2025-12-19T11:01:36.059371-05:00","created_by":"daemon"},{"issue_id":"prt-3by","depends_on_id":"prt-tsv","type":"blocks","created_at":"2025-12-19T11:08:54.526654-05:00","created_by":"daemon"}]}
{"id":"prt-3rn","title":"CLI Implementation","description":"## Overview\nImplement the command-line interface using Cobra. This is the user's entry point to PRT.\n\n## Command Structure\n```\nprt [flags]\n\nFlags:\n  -p, --path strings     Search paths (overrides config, can repeat)\n  -f, --filter string    Filter repos by name pattern (glob)\n  -g, --group string     Group by: project, author\n  -d, --depth int        Scan depth (default: from config)\n      --json             Output as JSON\n      --no-color         Disable colored output\n  -h, --help             Show help\n  -v, --version          Show version\n```\n\n## Execution Flow\n1. Parse flags\n2. Load config (with flag overrides)\n3. Validate config (trigger wizard if needed)\n4. Check gh CLI availability\n5. Scan for repositories\n6. Fetch PRs (with progress)\n7. Detect stacks\n8. Categorize PRs\n9. Render output\n\n## Components\n\n### Root Command (`internal/cli/root.go`)\n```go\nvar rootCmd = \u0026cobra.Command{\n    Use:   \"prt\",\n    Short: \"GitHub PR Tracker\",\n    Long:  \"Aggregate PR status across multiple local repositories...\",\n    RunE:  runPRT,\n}\n```\n\n### Flags (`internal/cli/flags.go`)\n- Define all flags\n- Bind to viper for config integration\n- Validation functions\n\n## Flag Details\n\n### --path / -p\nOverride search_paths from config. Can be specified multiple times:\n`prt -p ~/work -p ~/oss`\n\n### --filter / -f\nGlob pattern to filter repos by name:\n`prt -f \"api-*\"`\n\n### --group / -g\nOverride grouping:\n- `project`: Group PRs by repository (default)\n- `author`: Group PRs by author\n\n### --depth / -d\nOverride scan_depth for this run.\n\n### --json\nOutput raw JSON instead of styled text. Useful for scripting:\n`prt --json | jq '.needsMyAttention | length'`\n\n### --no-color\nDisable all ANSI color codes. Useful for:\n- Piping to files\n- Terminals without color support\n- Accessibility\n\n## Help Text\n```\nPRT - GitHub PR Tracker\n\nAggregate and visualize GitHub Pull Request status across multiple\nlocal repositories. Highlights PRs requiring your attention and\nshows stacked PR relationships.\n\nUsage:\n  prt [flags]\n\nFlags:\n  -p, --path strings     Search paths (overrides config)\n  -f, --filter string    Filter repos by name pattern\n  -g, --group string     Group by: project, author\n  -d, --depth int        Scan depth (default 3)\n      --json             JSON output\n      --no-color         Disable colors\n  -h, --help             Show this help\n  -v, --version          Show version\n\nConfiguration:\n  Config file: ~/.prt/config.yaml\n  First run will launch setup wizard.\n\nExamples:\n  prt                        Show all PRs\n  prt -p ~/work              Scan specific path\n  prt -f \"api-*\"             Only api-* repos\n  prt --json | jq            Pipe to jq\n\nMore info: https://github.com/ChrisEdwards/prt\n```\n\n## Acceptance Criteria\n- [ ] All flags work correctly\n- [ ] --help shows complete help text\n- [ ] --version shows embedded version\n- [ ] Config loaded with flag precedence\n- [ ] Missing config triggers wizard\n- [ ] Full execution flow works end-to-end\n- [ ] Exit codes: 0 success, 1 error\n- [ ] Integration tests for common scenarios","status":"open","priority":2,"issue_type":"epic","created_at":"2025-12-19T10:35:02.912751-05:00","updated_at":"2025-12-19T11:02:20.074724-05:00"}
{"id":"prt-47k","title":"Build \u0026 Distribution","description":"## Overview\nSet up build tooling, cross-compilation, and distribution via Homebrew.\n\n## Build Targets\n\n### Makefile\n```makefile\nVERSION ?= $(shell git describe --tags --always --dirty)\nLDFLAGS = -ldflags \"-X main.version=$(VERSION)\"\n\nbuild:           # Build for current platform\ntest:            # Run all tests\ntest-coverage:   # Run tests with coverage report\nclean:           # Remove build artifacts\ninstall:         # Install to /usr/local/bin\nrelease:         # Build for all platforms\nlint:            # Run golangci-lint\nfmt:             # Format code\n```\n\n### Platforms\n| OS | Arch | Artifact |\n|----|------|----------|\n| macOS | amd64 | prt-darwin-amd64 |\n| macOS | arm64 | prt-darwin-arm64 |\n| Linux | amd64 | prt-linux-amd64 |\n\n## Version Embedding\n```go\n// cmd/prt/main.go\nvar version = \"dev\" // Overwritten by ldflags\n\nfunc main() {\n    rootCmd.Version = version\n}\n```\n\nBuild with: `go build -ldflags \"-X main.version=v1.0.0\"`\n\n## Release Artifacts\nFor each release:\n1. Build binaries for all platforms\n2. Create tarballs: `prt-darwin-arm64.tar.gz`\n3. Generate checksums: `checksums.txt`\n4. Create GitHub release with assets\n\n## GoReleaser (Optional Automation)\n`.goreleaser.yaml` automates:\n- Multi-platform builds\n- Tarball creation\n- Checksum generation\n- GitHub release creation\n- Homebrew formula updates\n\n## Homebrew Distribution\n\n### Tap Repository\nUse existing: `ChrisEdwards/homebrew-tap`\n\n### Formula (`Formula/prt.rb`)\n```ruby\nclass Prt \u003c Formula\n  desc \"GitHub PR Tracker - Aggregate PR status across multiple repositories\"\n  homepage \"https://github.com/ChrisEdwards/prt\"\n  version \"1.0.0\"\n  license \"MIT\"\n\n  on_macos do\n    if Hardware::CPU.arm?\n      url \"https://github.com/.../prt-darwin-arm64.tar.gz\"\n      sha256 \"...\"\n    else\n      url \"https://github.com/.../prt-darwin-amd64.tar.gz\"\n      sha256 \"...\"\n    end\n  end\n\n  depends_on \"gh\" =\u003e :recommended\n\n  def install\n    bin.install \"prt\"\n  end\n\n  def caveats\n    \u003c\u003c~EOS\n      PRT requires the GitHub CLI (gh) to be installed and authenticated.\n      Run `prt` to start the setup wizard.\n    EOS\n  end\nend\n```\n\n### Installation Commands\n```bash\nbrew tap ChrisEdwards/tap\nbrew install prt\n# or\nbrew install ChrisEdwards/tap/prt\n```\n\n## Installation Methods Summary\n| Method | Command | Audience |\n|--------|---------|----------|\n| Homebrew | `brew install ChrisEdwards/tap/prt` | macOS users |\n| Go Install | `go install github.com/ChrisEdwards/prt@latest` | Go developers |\n| Binary | Download from releases | CI/CD, Linux users |\n\n## Documentation\nREADME.md should include:\n- What PRT does (with screenshot)\n- Installation instructions (all methods)\n- Quick start guide\n- Configuration reference\n- Troubleshooting\n\n## Acceptance Criteria\n- [ ] `make build` produces working binary\n- [ ] `make release` builds all platforms\n- [ ] Version correctly embedded in binary\n- [ ] GoReleaser config valid (optional)\n- [ ] Homebrew formula installs correctly\n- [ ] README is comprehensive\n- [ ] License file present (MIT)\n\n## Future Considerations (Out of Scope v1)\n- GitHub Actions CI/CD\n- Automatic formula updates on release\n- Linux package managers (apt, yum)\n- Windows support","status":"open","priority":3,"issue_type":"epic","created_at":"2025-12-19T10:35:29.947537-05:00","updated_at":"2025-12-19T11:02:20.076098-05:00"}
{"id":"prt-5eu","title":"Define Config struct with yaml/mapstructure tags","description":"## Task\nCreate the Config struct definition with proper tags for Viper integration.\n\n## File: internal/config/types.go\n\n## Struct Definition\n```go\npackage config\n\ntype Config struct {\n    // Identity\n    GitHubUsername string `yaml:\"github_username\" mapstructure:\"github_username\"`\n    \n    // Team\n    TeamMembers []string `yaml:\"team_members\" mapstructure:\"team_members\"`\n    \n    // Repository Discovery\n    SearchPaths  []string `yaml:\"search_paths\" mapstructure:\"search_paths\"`\n    IncludeRepos []string `yaml:\"include_repos\" mapstructure:\"include_repos\"`\n    ScanDepth    int      `yaml:\"scan_depth\" mapstructure:\"scan_depth\"`\n    \n    // Known Bots\n    Bots []string `yaml:\"bots\" mapstructure:\"bots\"`\n    \n    // Display\n    DefaultGroupBy string `yaml:\"default_group_by\" mapstructure:\"default_group_by\"`\n    DefaultSort    string `yaml:\"default_sort\" mapstructure:\"default_sort\"`\n    ShowBranchName bool   `yaml:\"show_branch_name\" mapstructure:\"show_branch_name\"`\n    ShowIcons      bool   `yaml:\"show_icons\" mapstructure:\"show_icons\"`\n}\n\n// Constants for GroupBy options\nconst (\n    GroupByProject = \"project\"\n    GroupByAuthor  = \"author\"\n)\n\n// Constants for Sort options\nconst (\n    SortOldest = \"oldest\"\n    SortNewest = \"newest\"\n)\n```\n\n## Why Both Tags?\n- `yaml`: For direct YAML parsing\n- `mapstructure`: For Viper's Unmarshal function\n\n## Acceptance Criteria\n- [ ] Config struct compiles\n- [ ] All fields have yaml and mapstructure tags\n- [ ] GroupBy and Sort constants defined\n- [ ] Tags use snake_case to match YAML keys\n\n## Part of Epic\nConfiguration System (prt-v3f)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-19T10:39:23.744654-05:00","updated_at":"2025-12-19T10:39:23.744654-05:00","dependencies":[{"issue_id":"prt-5eu","depends_on_id":"prt-mt5","type":"blocks","created_at":"2025-12-19T10:48:48.520702-05:00","created_by":"daemon"},{"issue_id":"prt-5eu","depends_on_id":"prt-v3f","type":"parent-child","created_at":"2025-12-19T11:01:03.974259-05:00","created_by":"daemon"}]}
{"id":"prt-5un","title":"Implement JSON output formatter","description":"## Task\nOutput the full scan result as JSON for scripting.\n\n## File: internal/display/json.go\n\n## Implementation\n```go\nfunc RenderJSON(result *models.ScanResult) (string, error) {\n    // Custom encoder for pretty output\n    data, err := json.MarshalIndent(result, \"\", \"  \")\n    if err \\!= nil {\n        return \"\", fmt.Errorf(\"failed to marshal result: %w\", err)\n    }\n    return string(data), nil\n}\n```\n\n## Usage\n```bash\nprt --json | jq '.myPRs | length'\nprt --json | jq '.needsMyAttention[].url'\nprt --json \u003e ~/pr-snapshot.json\n```\n\n## JSON Structure\n```json\n{\n  \"myPRs\": [...],\n  \"needsMyAttention\": [...],\n  \"teamPRs\": [...],\n  \"otherPRs\": [...],\n  \"reposWithPRs\": [...],\n  \"reposWithoutPRs\": [...],\n  \"reposWithErrors\": [...],\n  \"stacks\": {...},\n  \"totalReposScanned\": 5,\n  \"totalPRsFound\": 12,\n  \"scanDuration\": 2300000000,\n  \"username\": \"jdoe\"\n}\n```\n\n## Duration Handling\nGo's time.Duration marshals as nanoseconds (int64). Users can convert:\n```bash\njq '.scanDuration / 1000000000' # Convert to seconds\n```\n\n## Acceptance Criteria\n- [ ] Valid JSON output\n- [ ] Pretty-printed (indented)\n- [ ] All fields included\n- [ ] Works with jq\n- [ ] Unit test validates JSON structure\n\n## Part of Epic\nDisplay System (prt-75i)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-19T10:45:17.508236-05:00","updated_at":"2025-12-19T10:45:17.508236-05:00","dependencies":[{"issue_id":"prt-5un","depends_on_id":"prt-bcw","type":"blocks","created_at":"2025-12-19T10:50:22.775522-05:00","created_by":"daemon"},{"issue_id":"prt-5un","depends_on_id":"prt-75i","type":"parent-child","created_at":"2025-12-19T11:01:52.719899-05:00","created_by":"daemon"}]}
{"id":"prt-5zd","title":"Implement sorting within categories","description":"## Task\nSort PRs within each category by creation date.\n\n## File: internal/categorizer/sorter.go\n\n## Implementation\n```go\nfunc SortPRs(prs []*models.PR, order string) {\n    switch order {\n    case config.SortOldest:\n        sort.Slice(prs, func(i, j int) bool {\n            return prs[i].CreatedAt.Before(prs[j].CreatedAt)\n        })\n    case config.SortNewest:\n        sort.Slice(prs, func(i, j int) bool {\n            return prs[i].CreatedAt.After(prs[j].CreatedAt)\n        })\n    default:\n        // Default to oldest first\n        sort.Slice(prs, func(i, j int) bool {\n            return prs[i].CreatedAt.Before(prs[j].CreatedAt)\n        })\n    }\n}\n\n// After categorization, sort all categories\nfunc (c *categorizer) sortResult(result *models.ScanResult, order string) {\n    SortPRs(result.MyPRs, order)\n    SortPRs(result.NeedsMyAttention, order)\n    SortPRs(result.TeamPRs, order)\n    SortPRs(result.OtherPRs, order)\n}\n```\n\n## Why \"Oldest First\" as Default?\n- Highlights stale PRs that need attention\n- Encourages FIFO review order\n- Prevents old PRs from being forgotten\n\n## Secondary Sort\nFor PRs with same creation time, sort by PR number:\n```go\nsort.Slice(prs, func(i, j int) bool {\n    if prs[i].CreatedAt.Equal(prs[j].CreatedAt) {\n        return prs[i].Number \u003c prs[j].Number\n    }\n    return prs[i].CreatedAt.Before(prs[j].CreatedAt)\n})\n```\n\n## Acceptance Criteria\n- [ ] Oldest first sorting works\n- [ ] Newest first sorting works\n- [ ] All categories sorted\n- [ ] Stable sort for equal times\n- [ ] Unit tests\n\n## Part of Epic\nPR Categorization (prt-zsl)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-19T10:44:01.773958-05:00","updated_at":"2025-12-19T10:44:01.773958-05:00","dependencies":[{"issue_id":"prt-5zd","depends_on_id":"prt-uym","type":"blocks","created_at":"2025-12-19T10:49:56.587787-05:00","created_by":"daemon"},{"issue_id":"prt-5zd","depends_on_id":"prt-zsl","type":"parent-child","created_at":"2025-12-19T11:01:38.662361-05:00","created_by":"daemon"}]}
{"id":"prt-62e","title":"Implement glob pattern filtering","description":"## Task\nFilter discovered repositories by name using glob patterns.\n\n## File: internal/scanner/filter.go\n\n## Glob Library\nUsing `github.com/gobwas/glob` for pattern matching.\n\n## Pattern Examples\n- `myorg-*` - repos starting with 'myorg-'\n- `*-api` - repos ending with '-api'\n- `frontend` - exact match\n- `*service*` - contains 'service'\n\n## Implementation\n```go\nfunc (s *scanner) matchesIncludePatterns(name string) bool {\n    // No patterns = match all\n    if len(s.includeGlob) == 0 {\n        return true\n    }\n    \n    // Match against any pattern\n    for _, g := range s.includeGlob {\n        if g.Match(name) {\n            return true\n        }\n    }\n    \n    return false\n}\n```\n\n## Pattern Compilation (in NewScanner)\n```go\nfor _, pattern := range includePatterns {\n    g, err := glob.Compile(pattern)\n    if err != nil {\n        return nil, fmt.Errorf(\"invalid glob pattern %q: %w\", pattern, err)\n    }\n    globs = append(globs, g)\n}\n```\n\n## Behavior\n- Empty `include_repos` config -\u003e all repos included\n- Multiple patterns -\u003e OR logic (match any)\n- Pattern match is on repo name only, not full path\n- Case sensitive (GitHub repo names are case-sensitive)\n\n## Acceptance Criteria\n- [ ] Empty patterns match all repos\n- [ ] Prefix patterns work (myorg-*)\n- [ ] Suffix patterns work (*-api)\n- [ ] Exact match works\n- [ ] Invalid pattern returns helpful error\n- [ ] Unit tests for all pattern types\n\n## Part of Epic\nRepository Scanner (prt-bhq)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-19T10:42:34.621494-05:00","updated_at":"2025-12-19T10:42:34.621494-05:00","dependencies":[{"issue_id":"prt-62e","depends_on_id":"prt-mt5","type":"blocks","created_at":"2025-12-19T10:49:34.435915-05:00","created_by":"daemon"},{"issue_id":"prt-62e","depends_on_id":"prt-bhq","type":"parent-child","created_at":"2025-12-19T11:01:34.24838-05:00","created_by":"daemon"}]}
{"id":"prt-6bj","title":"Implement GetCurrentUser via gh api","description":"## Task\nRetrieve the authenticated GitHub username using gh CLI.\n\n## File: internal/github/client.go\n\n## Implementation\n```go\nfunc (c *client) GetCurrentUser() (string, error) {\n    cmd := exec.Command(\"gh\", \"api\", \"user\", \"--jq\", \".login\")\n    \n    out, err := cmd.Output()\n    if err != nil {\n        // Try to get more info from stderr\n        if exitErr, ok := err.(*exec.ExitError); ok {\n            return \"\", fmt.Errorf(\"failed to get current user: %s\", string(exitErr.Stderr))\n        }\n        return \"\", fmt.Errorf(\"failed to get current user: %w\", err)\n    }\n    \n    username := strings.TrimSpace(string(out))\n    if username == \"\" {\n        return \"\", fmt.Errorf(\"empty username returned from GitHub API\")\n    }\n    \n    return username, nil\n}\n```\n\n## Why `gh api user` Instead of `gh auth status`?\n- `gh api user` returns the actual GitHub username\n- `gh auth status` output is harder to parse\n- `--jq .login` extracts just the username cleanly\n\n## Use Case\nWhen config has empty github_username, auto-detect:\n```go\nif cfg.GitHubUsername == \"\" {\n    user, err := client.GetCurrentUser()\n    if err != nil {\n        return fmt.Errorf(\"cannot determine GitHub username: %w\", err)\n    }\n    cfg.GitHubUsername = user\n}\n```\n\n## Acceptance Criteria\n- [ ] Returns authenticated username\n- [ ] Handles errors gracefully\n- [ ] Trims whitespace from output\n- [ ] Unit tests with mocked exec\n\n## Part of Epic\nGitHub CLI Integration (prt-749)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-19T10:41:17.692514-05:00","updated_at":"2025-12-19T10:41:17.692514-05:00","dependencies":[{"issue_id":"prt-6bj","depends_on_id":"prt-2ll","type":"blocks","created_at":"2025-12-19T10:49:03.91298-05:00","created_by":"daemon"},{"issue_id":"prt-6bj","depends_on_id":"prt-749","type":"parent-child","created_at":"2025-12-19T11:01:16.205532-05:00","created_by":"daemon"}]}
{"id":"prt-6x3","title":"Create main.go entry point","description":"## Task\nCreate the application entry point with proper error handling and panic recovery.\n\n## File: cmd/prt/main.go\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \n    \"prt/internal/cli\"\n)\n\nvar version = \"dev\" // Set by ldflags at build time\n\nfunc main() {\n    defer func() {\n        if r := recover(); r != nil {\n            fmt.Fprintf(os.Stderr, \"Fatal error: %v\\n\", r)\n            os.Exit(1)\n        }\n    }()\n    \n    if err := cli.Execute(version); err != nil {\n        os.Exit(1)\n    }\n}\n```\n\n## Why Panic Recovery?\nUncaught panics produce ugly stack traces. The recovery wrapper ensures a clean error message even if something unexpected happens.\n\n## Why version Variable?\nThe ldflags build process sets this at compile time:\n`go build -ldflags \"-X main.version=v1.0.0\"`\n\n## Acceptance Criteria\n- [ ] main.go compiles (with stub cli package)\n- [ ] Panic recovery works (test with intentional panic)\n- [ ] Version variable can be overridden by ldflags\n\n## Part of Epic\nProject Foundation \u0026 Scaffolding (prt-ai4)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-19T10:37:16.836236-05:00","updated_at":"2025-12-19T10:37:16.836236-05:00","dependencies":[{"issue_id":"prt-6x3","depends_on_id":"prt-mt5","type":"blocks","created_at":"2025-12-19T10:47:58.568419-05:00","created_by":"daemon"},{"issue_id":"prt-6x3","depends_on_id":"prt-ai4","type":"parent-child","created_at":"2025-12-19T11:00:13.943696-05:00","created_by":"daemon"},{"issue_id":"prt-6x3","depends_on_id":"prt-ciu","type":"blocks","created_at":"2025-12-19T11:08:54.303614-05:00","created_by":"daemon"}]}
{"id":"prt-749","title":"GitHub CLI Integration","description":"## Overview\nImplement a wrapper around the `gh` CLI for all GitHub interactions. This approach leverages GitHub's official CLI for authentication handling and API access.\n\n## Why gh CLI Instead of Direct API?\n1. **Auth handled**: gh manages OAuth tokens, SSO, enterprise configs\n2. **Maintained by GitHub**: Always up-to-date with API changes\n3. **Widely installed**: Many developers already have it\n4. **Simple**: No API client code to maintain\n\n## Components\n\n### Client Interface (`internal/github/client.go`)\n```go\ntype Client interface {\n    Check() error                              // Verify gh exists and is authed\n    GetCurrentUser() (string, error)           // Get authenticated username\n    ListPRs(repoPath string) ([]*models.PR, error) // Fetch PRs for a repo\n}\n```\n\n### JSON Parsing (`internal/github/parser.go`)\nParse output from:\n```bash\ngh pr list --json number,title,url,author,state,isDraft,createdAt,baseRefName,headRefName,statusCheckRollup,reviewRequests,assignees,reviews\n```\n\n### Retry Logic (`internal/github/retry.go`)\n- Max attempts: 3\n- Initial wait: 1s\n- Max wait: 10s\n- Exponential backoff: wait * 2^(attempt-1)\n- Only retry network errors, not auth errors\n\n### Error Types (`internal/github/types.go`)\n- `GHNotFoundError`: gh CLI not installed\n- `GHAuthError`: gh not authenticated\n- `RepoScanError`: repo-specific failure\n- `NetworkError`: network issues after retries\n- `RateLimitError`: GitHub API rate limit hit\n\n## Error Handling Matrix\n| Error | Detection | Action |\n|-------|-----------|--------|\n| gh not found | exec.LookPath | Exit with install instructions |\n| gh not authed | gh auth status | Exit with login instructions |\n| Network timeout | gh execution | Retry with backoff |\n| Rate limit | gh output | Exit with wait message |\n| Repo auth error | gh output | Skip repo, continue |\n\n## Acceptance Criteria\n- [ ] Check() detects missing gh and gives install instructions\n- [ ] Check() detects unauthenticated gh and gives login instructions\n- [ ] GetCurrentUser() returns username from `gh api user`\n- [ ] ListPRs() parses all PR fields correctly\n- [ ] Retry logic works with exponential backoff\n- [ ] Error types are properly classified\n- [ ] Unit tests with mock exec\n\n## gh Output Format\nThe JSON from gh pr list has nested objects:\n- author.login (not just author)\n- reviewRequests[].login\n- reviews[].author.login, reviews[].state, reviews[].submittedAt\n\nParser must handle this nesting correctly.","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-19T10:33:08.518302-05:00","updated_at":"2025-12-19T11:02:20.070404-05:00"}
{"id":"prt-755","title":"Implement config validation","description":"## Task\nValidate loaded configuration and provide helpful error messages.\n\n## File: internal/config/config.go (add to existing)\n\n## Validation Rules\n```go\nfunc (c *Config) Validate() error {\n    var errs []string\n    \n    // Username required\n    if c.GitHubUsername == \"\" {\n        errs = append(errs, \"github_username is required (set in config or via gh CLI auto-detect)\")\n    }\n    \n    // At least one search path\n    if len(c.SearchPaths) == 0 {\n        errs = append(errs, \"at least one search_path is required\")\n    }\n    \n    // Validate search paths exist\n    for _, path := range c.SearchPaths {\n        if _, err := os.Stat(path); os.IsNotExist(err) {\n            errs = append(errs, fmt.Sprintf(\"search path does not exist: %s\", path))\n        }\n    }\n    \n    // Valid group_by value\n    if c.DefaultGroupBy != GroupByProject \u0026\u0026 c.DefaultGroupBy != GroupByAuthor {\n        errs = append(errs, fmt.Sprintf(\"invalid default_group_by: %s (must be 'project' or 'author')\", c.DefaultGroupBy))\n    }\n    \n    // Valid sort value\n    if c.DefaultSort != SortOldest \u0026\u0026 c.DefaultSort != SortNewest {\n        errs = append(errs, fmt.Sprintf(\"invalid default_sort: %s (must be 'oldest' or 'newest')\", c.DefaultSort))\n    }\n    \n    // Scan depth must be positive\n    if c.ScanDepth \u003c 1 {\n        errs = append(errs, \"scan_depth must be at least 1\")\n    }\n    \n    if len(errs) \u003e 0 {\n        return \u0026ValidationError{Errors: errs}\n    }\n    \n    return nil\n}\n\ntype ValidationError struct {\n    Errors []string\n}\n\nfunc (e *ValidationError) Error() string {\n    return fmt.Sprintf(\"configuration errors:\\n  - %s\", strings.Join(e.Errors, \"\\n  - \"))\n}\n\n// NeedsSetup returns true if config requires setup wizard\nfunc (c *Config) NeedsSetup() bool {\n    return len(c.SearchPaths) == 0 || c.GitHubUsername == \"\"\n}\n```\n\n## Error Messages\nShould be clear and actionable:\n- BAD: \"invalid config\"\n- GOOD: \"github_username is required (set in config or via gh CLI auto-detect)\"\n\n## Acceptance Criteria\n- [ ] All validation rules implemented\n- [ ] Error messages are helpful\n- [ ] NeedsSetup() correctly identifies incomplete configs\n- [ ] Unit tests for each validation rule\n\n## Part of Epic\nConfiguration System (prt-v3f)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-19T10:39:26.676379-05:00","updated_at":"2025-12-19T10:39:26.676379-05:00","dependencies":[{"issue_id":"prt-755","depends_on_id":"prt-e31","type":"blocks","created_at":"2025-12-19T10:48:56.785148-05:00","created_by":"daemon"},{"issue_id":"prt-755","depends_on_id":"prt-v3f","type":"parent-child","created_at":"2025-12-19T11:01:05.744568-05:00","created_by":"daemon"}]}
{"id":"prt-75i","title":"Display System","description":"## Overview\nRender the categorized PRs to the terminal with beautiful styling using Lipgloss. The display is the user-facing part of PRT - it must be clear, scannable, and informative.\n\n## Output Structure\n```\nPRT ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\nüìã MY PRS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n  [repo-name]\n  ‚îú‚îÄ‚îÄ #402 Feature: Transformer Logic\n  ‚îÇ   Draft ¬∑ Created 4d ago ¬∑ CI ‚úÖ\n  ‚îÇ   https://github.com/org/repo/pull/402\n\nüëÄ NEEDS MY ATTENTION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n  [repo-name]  \n  ‚îî‚îÄ‚îÄ #156 Fix: Memory leak\n      Review requested ¬∑ Created 2d ago ¬∑ CI ‚ùå\n      @author-name\n      https://github.com/org/repo/pull/156\n\nüë• TEAM PRS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n  ...\n\nü§ñ OTHER PRS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n  ...\n\nüìÇ REPOS WITH NO OPEN PRS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n  ‚Ä¢ repo-a (/path/to/repo-a)\n  ‚Ä¢ repo-b (/path/to/repo-b)\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\nScanned 5 repos ¬∑ Found 6 PRs ¬∑ 2.3s\n```\n\n## Components\n\n### Styles (`internal/display/styles.go`)\n- Section headers: Bold, colored background\n- PR states: Draft (gray italic), Needs Review (green), Approved (blue), Changes Requested (orange)\n- CI status: Passing (green ‚úÖ), Failing (red ‚ùå), Pending (yellow ‚è≥)\n- Blocked PRs: Dimmed/faint\n- URLs: Blue, underlined\n\n### Sections (`internal/display/sections.go`)\n- RenderSection(title, icon, prs)\n- Handle empty states: 'None' or 'None - you're all caught up\\! üéâ'\n\n### Tree (`internal/display/tree.go`)\n- Unicode box-drawing: ‚îÇ ‚îú‚îÄ‚îÄ ‚îî‚îÄ‚îÄ\n- Recursive rendering for stacks\n- Child PRs indented and dimmed\n\n### PR Row (`internal/display/renderer.go`)\nEach PR shows:\n- Number and title\n- State (Draft, Waiting review, etc.)\n- Age\n- CI status\n- Author (for non-My PRs)\n- Branch info (optional)\n- URL (clickable in modern terminals)\n- Review status if applicable\n\n### Progress (`internal/display/progress.go`)\nDuring fetch:\n```\nScanning repositories...\n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 60% (3/5 repos)\n‚úì contrast-sdk (4 PRs)\n‚úì aiml-core (1 PR)\n‚†ã contrast-cli...\n```\n\n### JSON (`internal/display/json.go`)\nFor scripting: `prt --json | jq '.myPRs'`\nOutput the full ScanResult as JSON.\n\n## Icons\nWhen show_icons=true:\n- üìã My PRs, üëÄ Needs Attention, üë• Team, ü§ñ Other, üìÇ No PRs\n- ‚úÖ CI Pass, ‚ùå CI Fail, ‚è≥ CI Pending\n- üîí Blocked (stacked)\n\n## Acceptance Criteria\n- [ ] All 5 sections render correctly\n- [ ] Empty states handled gracefully\n- [ ] Stack trees render with proper indentation\n- [ ] Blocked PRs are visually dimmed\n- [ ] CI status icons display correctly\n- [ ] URLs are clickable (OSC 8 escape codes)\n- [ ] --no-color disables all styling\n- [ ] --json outputs valid JSON\n- [ ] Progress bar updates during fetch\n- [ ] Snapshot tests for consistent output","status":"open","priority":2,"issue_type":"epic","created_at":"2025-12-19T10:34:06.844387-05:00","updated_at":"2025-12-19T11:02:20.074047-05:00"}
{"id":"prt-7mh","title":"Implement tree rendering for stacked PRs","description":"## Task\nRender stacked PRs as trees with Unicode box-drawing characters.\n\n## File: internal/display/tree.go\n\n## Tree Characters\n```\n‚îú‚îÄ‚îÄ (branch)\n‚îî‚îÄ‚îÄ (last branch)  \n‚îÇ   (continuation)\n    (indent for children)\n```\n\n## Implementation\n```go\nfunc RenderStackTree(root *models.StackNode, showIcons, showBranches bool) string {\n    var b strings.Builder\n    renderNode(\u0026b, root, \"\", true, showIcons, showBranches)\n    return b.String()\n}\n\nfunc renderNode(b *strings.Builder, node *models.StackNode, prefix string, isLast bool, showIcons, showBranches bool) {\n    // Determine branch character\n    branch := TreeBranch\n    if isLast {\n        branch = TreeLastBranch\n    }\n    \n    // Render this PR\n    isBlocked := node.Parent != nil \u0026\u0026 !node.IsOrphan\n    prOutput := RenderPR(node.PR, prefix+branch, showIcons, showBranches, isBlocked)\n    b.WriteString(prOutput)\n    \n    // Render children\n    childPrefix := prefix\n    if isLast {\n        childPrefix += TreeIndent\n    } else {\n        childPrefix += TreeVertical + \"   \"\n    }\n    \n    for i, child := range node.Children {\n        isLastChild := i == len(node.Children)-1\n        renderNode(b, child, childPrefix, isLastChild, showIcons, showBranches)\n    }\n}\n```\n\n## Example Output\n```\n‚îú‚îÄ‚îÄ #402 Feature: Auth\n‚îÇ   Draft ¬∑ Created 4d ago ¬∑ CI ‚úÖ\n‚îÇ   feature/auth ‚Üí main\n‚îÇ   https://github.com/org/repo/pull/402\n‚îÇ\n‚îÇ   ‚îî‚îÄ‚îÄ #405 Tests for Auth (blocked)\n‚îÇ       Draft ¬∑ Created 2h ago ¬∑ CI ‚ùå\n‚îÇ       feature/auth-tests ‚Üí feature/auth\n‚îÇ       https://github.com/org/repo/pull/405\n```\n\n## Blocked Styling\nChildren with unmerged parents are \"blocked\":\n- Text is dimmed (faint)\n- Optionally show \"(blocked by #N)\" indicator\n\n## Acceptance Criteria\n- [ ] Tree renders correctly\n- [ ] Multi-level nesting works\n- [ ] Multiple children handled\n- [ ] Blocked PRs dimmed\n- [ ] Consistent indentation\n\n## Part of Epic\nDisplay System (prt-75i)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-19T10:45:16.462097-05:00","updated_at":"2025-12-19T10:45:16.462097-05:00","dependencies":[{"issue_id":"prt-7mh","depends_on_id":"prt-151","type":"blocks","created_at":"2025-12-19T10:50:21.515348-05:00","created_by":"daemon"},{"issue_id":"prt-7mh","depends_on_id":"prt-c43","type":"blocks","created_at":"2025-12-19T10:50:22.071394-05:00","created_by":"daemon"},{"issue_id":"prt-7mh","depends_on_id":"prt-75i","type":"parent-child","created_at":"2025-12-19T11:01:51.989981-05:00","created_by":"daemon"}]}
{"id":"prt-7r8","title":"Implement config defaults and known bots list","description":"## Task\nCreate default configuration values and the pre-populated list of known bot accounts.\n\n## File: internal/config/defaults.go\n\n## Default Config\n```go\nvar DefaultConfig = Config{\n    GitHubUsername: \"\",           // Must be set or auto-detected\n    TeamMembers:    []string{},\n    SearchPaths:    []string{},\n    IncludeRepos:   []string{},   // Empty = match all\n    ScanDepth:      3,\n    Bots:           KnownBots,\n    DefaultGroupBy: GroupByProject,\n    DefaultSort:    SortOldest,\n    ShowBranchName: true,\n    ShowIcons:      true,\n}\n```\n\n## Known Bots List\n```go\nvar KnownBots = []string{\n    \"dependabot[bot]\",\n    \"dependabot\",\n    \"renovate[bot]\",\n    \"renovate\",\n    \"github-actions[bot]\",\n    \"codecov[bot]\",\n    \"codecov\",\n    \"semantic-release-bot\",\n    \"greenkeeper[bot]\",\n    \"snyk-bot\",\n    \"imgbot[bot]\",\n    \"allcontributors[bot]\",\n    \"mergify[bot]\",\n    \"kodiakhq[bot]\",\n    \"stale[bot]\",\n}\n```\n\n## Path Helpers\n```go\nfunc ConfigDir() string {\n    home, _ := os.UserHomeDir()\n    return filepath.Join(home, \".prt\")\n}\n\nfunc ConfigPath() string {\n    return filepath.Join(ConfigDir(), \"config.yaml\")\n}\n```\n\n## Why These Bots?\nThese are the most common GitHub bots:\n- dependabot: Dependency updates\n- renovate: Dependency updates (alternative)\n- github-actions: CI automation\n- codecov: Coverage reports\n- Others: Various automation tools\n\nUsers can add their org-specific bots to the config.\n\n## Acceptance Criteria\n- [ ] DefaultConfig defined with sensible values\n- [ ] KnownBots list comprehensive\n- [ ] Path helpers return correct paths\n- [ ] ~ expansion works in paths\n\n## Part of Epic\nConfiguration System (prt-v3f)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-19T10:39:24.656536-05:00","updated_at":"2025-12-19T10:39:24.656536-05:00","dependencies":[{"issue_id":"prt-7r8","depends_on_id":"prt-5eu","type":"blocks","created_at":"2025-12-19T10:48:49.069278-05:00","created_by":"daemon"},{"issue_id":"prt-7r8","depends_on_id":"prt-v3f","type":"parent-child","created_at":"2025-12-19T11:01:04.556898-05:00","created_by":"daemon"}]}
{"id":"prt-89l","title":"Create Homebrew formula","description":"## Task\nCreate the Homebrew formula for PRT distribution.\n\n## File: (in ChrisEdwards/homebrew-tap repo) Formula/prt.rb\n\n## Formula\n```ruby\nclass Prt \u003c Formula\n  desc \"GitHub PR Tracker - Aggregate PR status across multiple repositories\"\n  homepage \"https://github.com/ChrisEdwards/prt\"\n  version \"1.0.0\"\n  license \"MIT\"\n\n  on_macos do\n    if Hardware::CPU.arm?\n      url \"https://github.com/ChrisEdwards/prt/releases/download/v#{version}/prt-darwin-arm64.tar.gz\"\n      sha256 \"PLACEHOLDER_ARM64_SHA\"\n    else\n      url \"https://github.com/ChrisEdwards/prt/releases/download/v#{version}/prt-darwin-amd64.tar.gz\"\n      sha256 \"PLACEHOLDER_AMD64_SHA\"\n    end\n  end\n\n  on_linux do\n    url \"https://github.com/ChrisEdwards/prt/releases/download/v#{version}/prt-linux-amd64.tar.gz\"\n    sha256 \"PLACEHOLDER_LINUX_SHA\"\n  end\n\n  depends_on \"gh\" =\u003e :recommended\n\n  def install\n    bin.install \"prt\"\n  end\n\n  def caveats\n    \u003c\u003c~EOS\n      PRT requires the GitHub CLI (gh) to be installed and authenticated.\n\n      If not already installed:\n        brew install gh\n\n      Then authenticate:\n        gh auth login\n\n      Run `prt` to start the setup wizard.\n    EOS\n  end\n\n  test do\n    assert_match \"prt version\", shell_output(\"#{bin}/prt --version\")\n  end\nend\n```\n\n## Installation\n```bash\nbrew tap ChrisEdwards/tap\nbrew install prt\n```\n\n## Release Process\n1. Build release binaries: `make release`\n2. Create tarballs for each binary\n3. Generate SHA256 checksums\n4. Create GitHub release with assets\n5. Update formula with new version and SHA256s\n\n## Acceptance Criteria\n- [ ] Formula valid (brew audit)\n- [ ] Installs correctly\n- [ ] Version test passes\n- [ ] Caveats displayed\n- [ ] gh dependency noted\n\n## Part of Epic\nBuild \u0026 Distribution (prt-47k)","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-19T10:46:40.172066-05:00","updated_at":"2025-12-19T10:46:40.172066-05:00","dependencies":[{"issue_id":"prt-89l","depends_on_id":"prt-8qs","type":"blocks","created_at":"2025-12-19T10:50:40.802726-05:00","created_by":"daemon"},{"issue_id":"prt-89l","depends_on_id":"prt-47k","type":"parent-child","created_at":"2025-12-19T11:01:55.753832-05:00","created_by":"daemon"}]}
{"id":"prt-8d2","title":"Write repository scanner unit tests","description":"## Task\nWrite comprehensive unit tests for the scanner package.\n\n## File: internal/scanner/scanner_test.go, git_test.go, filter_test.go\n\n## Test Utilities\n```go\n// Create a fake git repo for testing\nfunc createTestRepo(t *testing.T, name, remote string) string {\n    t.Helper()\n    dir := filepath.Join(t.TempDir(), name)\n    os.MkdirAll(filepath.Join(dir, \".git\"), 0755)\n    \n    // Create git config with remote\n    configPath := filepath.Join(dir, \".git\", \"config\")\n    config := fmt.Sprintf(`[remote \"origin\"]\n    url = %s\n`, remote)\n    os.WriteFile(configPath, []byte(config), 0644)\n    \n    return dir\n}\n```\n\n## Scanner Tests\n```go\nfunc TestScan_FindsRepos(t *testing.T) {\n    // Create temp structure with repos\n    // Verify all found\n}\n\nfunc TestScan_RespectsDepthLimit(t *testing.T) {\n    // Create repos at various depths\n    // With depth=2, verify deep repos skipped\n}\n\nfunc TestScan_SkipsSymlinks(t *testing.T) {\n    // Create symlink to repo\n    // Verify symlink not followed\n}\n\nfunc TestScan_HandlesMissingPaths(t *testing.T) {\n    // Config with non-existent path\n    // Should not error, just skip\n}\n\nfunc TestScan_AppliesGlobFilter(t *testing.T) {\n    // Create repos: api-users, api-orders, frontend\n    // Filter api-* -\u003e only api-* repos returned\n}\n\nfunc TestScan_NoDuplicates(t *testing.T) {\n    // Overlapping search paths\n    // Verify no duplicate repos\n}\n```\n\n## Git Tests\n```go\nfunc TestParseGitHubRemote_SSH(t *testing.T) {\n    tests := []struct {\n        url    string\n        owner  string\n        repo   string\n    }{\n        {\"git@github.com:owner/repo.git\", \"owner\", \"repo\"},\n        {\"git@github.com:owner/repo\", \"owner\", \"repo\"},\n    }\n    // ...\n}\n\nfunc TestParseGitHubRemote_HTTPS(t *testing.T) {}\nfunc TestParseGitHubRemote_NonGitHub(t *testing.T) {}\n```\n\n## Filter Tests\n```go\nfunc TestMatchesIncludePatterns_EmptyPatterns(t *testing.T) {}\nfunc TestMatchesIncludePatterns_PrefixMatch(t *testing.T) {}\nfunc TestMatchesIncludePatterns_SuffixMatch(t *testing.T) {}\nfunc TestMatchesIncludePatterns_ExactMatch(t *testing.T) {}\nfunc TestMatchesIncludePatterns_NoMatch(t *testing.T) {}\n```\n\n## Acceptance Criteria\n- [ ] All scanner behaviors tested\n- [ ] URL parsing edge cases covered\n- [ ] Glob patterns tested\n- [ ] Tests use temp directories (clean up)\n- [ ] Coverage \u003e 90%\n\n## Part of Epic\nRepository Scanner (prt-bhq)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-19T10:42:38.056019-05:00","updated_at":"2025-12-19T10:42:38.056019-05:00","dependencies":[{"issue_id":"prt-8d2","depends_on_id":"prt-ua5","type":"blocks","created_at":"2025-12-19T10:49:38.231625-05:00","created_by":"daemon"},{"issue_id":"prt-8d2","depends_on_id":"prt-ee6","type":"blocks","created_at":"2025-12-19T10:49:38.827524-05:00","created_by":"daemon"},{"issue_id":"prt-8d2","depends_on_id":"prt-62e","type":"blocks","created_at":"2025-12-19T10:49:39.448256-05:00","created_by":"daemon"},{"issue_id":"prt-8d2","depends_on_id":"prt-bhq","type":"parent-child","created_at":"2025-12-19T11:01:34.889927-05:00","created_by":"daemon"}]}
{"id":"prt-8qs","title":"Create Makefile with all targets","description":"## Task\nFinalize the Makefile with all build, test, and release targets.\n\n## File: Makefile\n\n## Implementation\n```makefile\n.PHONY: build test test-coverage clean install release lint fmt help\n\n# Version from git\nVERSION ?= $(shell git describe --tags --always --dirty 2\u003e/dev/null || echo \"dev\")\nLDFLAGS = -ldflags \"-X main.version=$(VERSION)\"\n\n# Build for current platform\nbuild:\n\t@echo \"Building prt $(VERSION)...\"\n\t@go build $(LDFLAGS) -o bin/prt ./cmd/prt\n\n# Run tests\ntest:\n\t@go test ./... -v\n\n# Run tests with coverage\ntest-coverage:\n\t@go test ./... -coverprofile=coverage.out\n\t@go tool cover -func=coverage.out\n\t@go tool cover -html=coverage.out -o coverage.html\n\t@echo \"Coverage report: coverage.html\"\n\n# Clean build artifacts\nclean:\n\t@rm -rf bin/\n\t@rm -f coverage.out coverage.html\n\n# Install to /usr/local/bin\ninstall: build\n\t@cp bin/prt /usr/local/bin/\n\t@echo \"Installed prt to /usr/local/bin/prt\"\n\n# Build for all platforms\nrelease: clean\n\t@echo \"Building releases...\"\n\t@GOOS=darwin GOARCH=amd64 go build $(LDFLAGS) -o bin/prt-darwin-amd64 ./cmd/prt\n\t@GOOS=darwin GOARCH=arm64 go build $(LDFLAGS) -o bin/prt-darwin-arm64 ./cmd/prt\n\t@GOOS=linux GOARCH=amd64 go build $(LDFLAGS) -o bin/prt-linux-amd64 ./cmd/prt\n\t@echo \"Release binaries:\"\n\t@ls -la bin/\n\n# Run linter\nlint:\n\t@which golangci-lint \u003e /dev/null || (echo \"Installing golangci-lint...\" \u0026\u0026 go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest)\n\t@golangci-lint run\n\n# Format code\nfmt:\n\t@go fmt ./...\n\n# Show help\nhelp:\n\t@echo \"PRT Makefile targets:\"\n\t@echo \"  build         - Build for current platform\"\n\t@echo \"  test          - Run tests\"\n\t@echo \"  test-coverage - Run tests with coverage report\"\n\t@echo \"  clean         - Remove build artifacts\"\n\t@echo \"  install       - Install to /usr/local/bin\"\n\t@echo \"  release       - Build for all platforms\"\n\t@echo \"  lint          - Run golangci-lint\"\n\t@echo \"  fmt           - Format code\"\n```\n\n## Acceptance Criteria\n- [ ] make build works\n- [ ] make test runs all tests\n- [ ] make coverage generates report\n- [ ] make release builds all platforms\n- [ ] make install installs binary\n- [ ] VERSION embedded correctly\n\n## Part of Epic\nBuild \u0026 Distribution (prt-47k)","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-19T10:46:39.20327-05:00","updated_at":"2025-12-19T10:46:39.20327-05:00","dependencies":[{"issue_id":"prt-8qs","depends_on_id":"prt-ukh","type":"blocks","created_at":"2025-12-19T10:50:40.258996-05:00","created_by":"daemon"},{"issue_id":"prt-8qs","depends_on_id":"prt-47k","type":"parent-child","created_at":"2025-12-19T11:01:55.070685-05:00","created_by":"daemon"}]}
{"id":"prt-a56","title":"Implement retry logic with exponential backoff","description":"## Task\nImplement retry logic for transient network failures.\n\n## File: internal/github/retry.go\n\n## Configuration\n```go\ntype RetryConfig struct {\n    MaxAttempts int           // Default: 3\n    InitialWait time.Duration // Default: 1s\n    MaxWait     time.Duration // Default: 10s\n}\n\nvar DefaultRetryConfig = RetryConfig{\n    MaxAttempts: 3,\n    InitialWait: time.Second,\n    MaxWait:     10 * time.Second,\n}\n```\n\n## Implementation\n```go\nfunc (c *client) withRetry(fn func() ([]*models.PR, error)) ([]*models.PR, error) {\n    var lastErr error\n    \n    for attempt := 1; attempt \u003c= c.retryConfig.MaxAttempts; attempt++ {\n        result, err := fn()\n        if err == nil {\n            return result, nil\n        }\n        \n        // Don't retry non-retriable errors\n        if !isRetriableError(err) {\n            return nil, err\n        }\n        \n        lastErr = err\n        \n        if attempt \u003c c.retryConfig.MaxAttempts {\n            wait := c.calculateBackoff(attempt)\n            // Could log: fmt.Printf(\"Retrying in %v... (%d/%d)\\n\", wait, attempt, c.retryConfig.MaxAttempts)\n            time.Sleep(wait)\n        }\n    }\n    \n    return nil, \u0026NetworkError{\n        Cause:   lastErr,\n        Retries: c.retryConfig.MaxAttempts,\n    }\n}\n\nfunc (c *client) calculateBackoff(attempt int) time.Duration {\n    // Exponential backoff: initialWait * 2^(attempt-1)\n    wait := c.retryConfig.InitialWait * time.Duration(1\u003c\u003c(attempt-1))\n    if wait \u003e c.retryConfig.MaxWait {\n        wait = c.retryConfig.MaxWait\n    }\n    return wait\n}\n\nfunc isRetriableError(err error) bool {\n    // Auth errors should not be retried\n    var authErr *GHAuthError\n    if errors.As(err, \u0026authErr) {\n        return false\n    }\n    \n    // Rate limit should not be retried immediately\n    var rateLimitErr *RateLimitError\n    if errors.As(err, \u0026rateLimitErr) {\n        return false\n    }\n    \n    // Network errors are retriable\n    return true\n}\n```\n\n## Backoff Schedule\n- Attempt 1: fail -\u003e wait 1s\n- Attempt 2: fail -\u003e wait 2s\n- Attempt 3: fail -\u003e return error\n\n## What Gets Retried\n- Timeout errors\n- Connection refused\n- DNS errors\n- Other transient network issues\n\n## What Doesn't Get Retried\n- Authentication errors\n- Rate limit errors\n- Parse errors\n- Repo not found\n\n## Acceptance Criteria\n- [ ] Retries on network errors\n- [ ] Does not retry auth errors\n- [ ] Exponential backoff implemented\n- [ ] Respects max wait cap\n- [ ] Unit tests for all scenarios\n\n## Part of Epic\nGitHub CLI Integration (prt-749)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-19T10:41:22.812843-05:00","updated_at":"2025-12-19T10:41:22.812843-05:00","dependencies":[{"issue_id":"prt-a56","depends_on_id":"prt-16a","type":"blocks","created_at":"2025-12-19T10:49:07.857383-05:00","created_by":"daemon"},{"issue_id":"prt-a56","depends_on_id":"prt-749","type":"parent-child","created_at":"2025-12-19T11:01:17.436442-05:00","created_by":"daemon"}]}
{"id":"prt-ai4","title":"Project Foundation \u0026 Scaffolding","description":"## Overview\nPRT (PR Tracker) is a Go CLI tool that aggregates GitHub PR status across multiple local repositories. This epic establishes the project foundation.\n\n## Problem Statement\nDevelopers working across multiple repositories suffer from 'PR Fatigue' - the cognitive burden of tracking PRs across many repos, remembering which need their review, understanding stacked PR relationships, and distinguishing between team PRs vs bot PRs.\n\n## Solution\nA single CLI command (`prt`) that scans configured directories, fetches PR data via `gh` CLI, categorizes by user role, detects stacked PRs, and displays a beautiful prioritized view.\n\n## This Epic Covers\n- Go module initialization with `prt` as module name (following abacus convention)\n- Directory structure per implementation spec\n- Basic Makefile (build, test, clean, install targets)\n- Main entry point with panic recovery\n- .gitignore setup\n\n## Technical Decisions\n- **Module name**: `prt` (not github.com/user/prt) - this is a CLI tool distributed as binary, not a library\n- **Go version**: 1.21+ (for modern features)\n- **Directory layout**: cmd/prt/main.go + internal/* packages\n\n## Acceptance Criteria\n- [ ] `go build ./...` succeeds\n- [ ] `make build` produces bin/prt binary\n- [ ] Directory structure matches implementation spec\n- [ ] main.go has panic recovery wrapper\n\n## Dependencies\nNone - this is the root of all work.\n\n## Future Self Notes\nThis foundation sets the stage for everything else. Keep it minimal - resist adding features here. The goal is a clean, buildable skeleton that other epics can build upon.","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-19T10:32:17.914633-05:00","updated_at":"2025-12-19T11:02:20.067298-05:00"}
{"id":"prt-ain","title":"Create README documentation","description":"## Task\nWrite comprehensive README documentation.\n\n## File: README.md\n\n## Structure\n```markdown\n# PRT - PR Tracker\n\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](...)\n\n\u003e Aggregate GitHub PR status across multiple local repositories\n\nPRT solves \"PR Fatigue\" by showing you:\n- PRs you authored\n- PRs awaiting your review\n- Team member PRs\n- Stacked PR relationships\n\n![Screenshot](docs/screenshot.png)\n\n## Installation\n\n### Homebrew (macOS)\n\\`\\`\\`bash\nbrew tap ChrisEdwards/tap\nbrew install prt\n\\`\\`\\`\n\n### Go Install\n\\`\\`\\`bash\ngo install github.com/ChrisEdwards/prt@latest\n\\`\\`\\`\n\n### Binary Download\nDownload from [Releases](https://github.com/ChrisEdwards/prt/releases)\n\n## Quick Start\n\n1. Run `prt` to launch the setup wizard\n2. Configure your search paths and team members\n3. Run `prt` to see your PR dashboard\n\n## Configuration\n\nConfig file: `~/.prt/config.yaml`\n\n\\`\\`\\`yaml\ngithub_username: \"jdoe\"\nteam_members:\n  - \"alice\"\n  - \"bob\"\nsearch_paths:\n  - \"~/code/work\"\ninclude_repos:\n  - \"myorg-*\"\n\\`\\`\\`\n\n## Usage\n\n\\`\\`\\`bash\nprt                    # Show PR dashboard\nprt -p ~/code/work     # Scan specific path\nprt -f \"api-*\"         # Filter repos by pattern\nprt --json | jq        # JSON output for scripting\n\\`\\`\\`\n\n## Flags\n\n| Flag | Description |\n|------|-------------|\n| -p, --path | Override search paths |\n| -f, --filter | Filter repos by pattern |\n| -g, --group | Group by: project, author |\n| -d, --depth | Scan depth (default 3) |\n| --json | JSON output |\n| --no-color | Disable colors |\n\n## Requirements\n\n- GitHub CLI (`gh`) installed and authenticated\n- macOS or Linux\n\n## License\n\nMIT\n```\n\n## Acceptance Criteria\n- [ ] Installation instructions clear\n- [ ] Configuration documented\n- [ ] All flags documented\n- [ ] Examples provided\n- [ ] Screenshot included (after UI complete)\n\n## Part of Epic\nBuild \u0026 Distribution (prt-47k)","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-19T10:46:43.751569-05:00","updated_at":"2025-12-19T10:46:43.751569-05:00","dependencies":[{"issue_id":"prt-ain","depends_on_id":"prt-0ar","type":"blocks","created_at":"2025-12-19T10:50:41.342036-05:00","created_by":"daemon"},{"issue_id":"prt-ain","depends_on_id":"prt-47k","type":"parent-child","created_at":"2025-12-19T11:01:56.299444-05:00","created_by":"daemon"}]}
{"id":"prt-am7","title":"Create .gitignore","description":"## Task\nCreate .gitignore for Go project.\n\n## Contents\n```gitignore\n# Binaries\nbin/\n*.exe\n*.exe~\n*.dll\n*.so\n*.dylib\nprt\n\n# Test artifacts\n*.test\ncoverage.out\ncoverage.html\n\n# Dependency directories\nvendor/\n\n# IDE\n.idea/\n.vscode/\n*.swp\n*.swo\n*~\n\n# OS\n.DS_Store\nThumbs.db\n\n# Build artifacts\ndist/\n```\n\n## Acceptance Criteria\n- [ ] .gitignore exists\n- [ ] bin/ directory ignored\n- [ ] Common IDE/OS files ignored\n\n## Part of Epic\nProject Foundation \u0026 Scaffolding (prt-ai4)","status":"in_progress","priority":1,"issue_type":"task","created_at":"2025-12-19T10:37:17.738663-05:00","updated_at":"2025-12-19T12:56:52.749674-05:00","dependencies":[{"issue_id":"prt-am7","depends_on_id":"prt-ai4","type":"parent-child","created_at":"2025-12-19T11:00:14.704113-05:00","created_by":"daemon"}]}
{"id":"prt-azv","title":"Write stack detection unit tests","description":"## Task\nComprehensive unit tests for the stack detection algorithm.\n\n## File: internal/stacks/detector_test.go\n\n## Test Cases\n```go\nfunc TestDetectStacks_NoStacks(t *testing.T) {\n    // All PRs target main -\u003e no parent-child relationships\n    prs := []*models.PR{\n        {Number: 1, HeadBranch: \"feature-a\", BaseBranch: \"main\"},\n        {Number: 2, HeadBranch: \"feature-b\", BaseBranch: \"main\"},\n        {Number: 3, HeadBranch: \"feature-c\", BaseBranch: \"main\"},\n    }\n    \n    stack := DetectStacks(prs)\n    \n    assert.Len(t, stack.Roots, 3)\n    for _, root := range stack.Roots {\n        assert.Empty(t, root.Children)\n        assert.Nil(t, root.Parent)\n        assert.Equal(t, 0, root.Depth)\n    }\n}\n\nfunc TestDetectStacks_SimpleStack(t *testing.T) {\n    // PR_2 depends on PR_1\n    prs := []*models.PR{\n        {Number: 1, HeadBranch: \"feature-a\", BaseBranch: \"main\"},\n        {Number: 2, HeadBranch: \"feature-a-tests\", BaseBranch: \"feature-a\"},\n    }\n    \n    stack := DetectStacks(prs)\n    \n    assert.Len(t, stack.Roots, 1)\n    root := stack.Roots[0]\n    assert.Equal(t, 1, root.PR.Number)\n    assert.Len(t, root.Children, 1)\n    assert.Equal(t, 2, root.Children[0].PR.Number)\n    assert.Equal(t, root, root.Children[0].Parent)\n}\n\nfunc TestDetectStacks_ThreeLevelStack(t *testing.T) {\n    // PR_3 -\u003e PR_2 -\u003e PR_1 -\u003e main\n    prs := []*models.PR{\n        {Number: 1, HeadBranch: \"feature-a\", BaseBranch: \"main\"},\n        {Number: 2, HeadBranch: \"feature-a-part2\", BaseBranch: \"feature-a\"},\n        {Number: 3, HeadBranch: \"feature-a-part3\", BaseBranch: \"feature-a-part2\"},\n    }\n    \n    stack := DetectStacks(prs)\n    \n    assert.Len(t, stack.Roots, 1)\n    assert.Equal(t, 0, stack.Roots[0].Depth)\n    assert.Equal(t, 1, stack.Roots[0].Children[0].Depth)\n    assert.Equal(t, 2, stack.Roots[0].Children[0].Children[0].Depth)\n}\n\nfunc TestDetectStacks_DiamondPattern(t *testing.T) {\n    // Two PRs depend on same parent\n    // PR_2 and PR_3 both depend on PR_1\n    prs := []*models.PR{\n        {Number: 1, HeadBranch: \"feature-a\", BaseBranch: \"main\"},\n        {Number: 2, HeadBranch: \"feature-a-ui\", BaseBranch: \"feature-a\"},\n        {Number: 3, HeadBranch: \"feature-a-api\", BaseBranch: \"feature-a\"},\n    }\n    \n    stack := DetectStacks(prs)\n    \n    assert.Len(t, stack.Roots, 1)\n    assert.Len(t, stack.Roots[0].Children, 2)\n}\n\nfunc TestDetectStacks_MultipleIndependentStacks(t *testing.T) {\n    // Two separate stacks in same repo\n    prs := []*models.PR{\n        {Number: 1, HeadBranch: \"feature-a\", BaseBranch: \"main\"},\n        {Number: 2, HeadBranch: \"feature-a-tests\", BaseBranch: \"feature-a\"},\n        {Number: 3, HeadBranch: \"feature-b\", BaseBranch: \"main\"},\n        {Number: 4, HeadBranch: \"feature-b-tests\", BaseBranch: \"feature-b\"},\n    }\n    \n    stack := DetectStacks(prs)\n    \n    assert.Len(t, stack.Roots, 2)\n}\n\nfunc TestDetectStacks_Empty(t *testing.T) {\n    stack := DetectStacks([]*models.PR{})\n    assert.Empty(t, stack.Roots)\n    assert.Empty(t, stack.AllNodes)\n}\n\nfunc TestDetectStacks_SinglePR(t *testing.T) {\n    prs := []*models.PR{\n        {Number: 1, HeadBranch: \"feature\", BaseBranch: \"main\"},\n    }\n    \n    stack := DetectStacks(prs)\n    \n    assert.Len(t, stack.Roots, 1)\n    assert.Empty(t, stack.Roots[0].Children)\n}\n```\n\n## Acceptance Criteria\n- [ ] All scenarios covered\n- [ ] Edge cases tested\n- [ ] Tests are deterministic\n- [ ] Clear test names\n\n## Part of Epic\nStack Detection Algorithm (prt-x7j)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-19T10:43:59.619742-05:00","updated_at":"2025-12-19T10:43:59.619742-05:00","dependencies":[{"issue_id":"prt-azv","depends_on_id":"prt-clj","type":"blocks","created_at":"2025-12-19T10:49:50.422455-05:00","created_by":"daemon"},{"issue_id":"prt-azv","depends_on_id":"prt-x7j","type":"parent-child","created_at":"2025-12-19T11:01:37.402905-05:00","created_by":"daemon"}]}
{"id":"prt-bcw","title":"Implement Result model","description":"## Task\nCreate the ScanResult model that aggregates all categorized PRs and metadata.\n\n## File: internal/models/result.go\n\n## Fields\n```go\ntype ScanResult struct {\n    // Categorized PRs\n    MyPRs            []*PR\n    NeedsMyAttention []*PR\n    TeamPRs          []*PR\n    OtherPRs         []*PR\n    \n    // Repository information\n    ReposWithPRs    []*Repository\n    ReposWithoutPRs []*Repository\n    ReposWithErrors []*Repository\n    \n    // Stack information (keyed by repo name)\n    Stacks map[string]*Stack\n    \n    // Metadata\n    TotalReposScanned int\n    TotalPRsFound     int\n    ScanDuration      time.Duration\n    Username          string\n}\n```\n\n## Purpose\nThis is the final output of the scan pipeline:\n1. Scanner finds repos\n2. GitHub client fetches PRs\n3. Stack detector builds trees\n4. Categorizer sorts PRs\n5. All assembled into ScanResult\n\n## JSON Serialization\nAll fields should serialize for --json output. The Duration will serialize as nanoseconds (standard Go behavior).\n\n## Acceptance Criteria\n- [ ] ScanResult struct compiles\n- [ ] All slices initialized (not nil)\n- [ ] Map initialized\n- [ ] JSON serialization works\n\n## Part of Epic\nData Models (prt-zib)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-19T10:38:03.611747-05:00","updated_at":"2025-12-19T10:38:03.611747-05:00","dependencies":[{"issue_id":"prt-bcw","depends_on_id":"prt-jn5","type":"blocks","created_at":"2025-12-19T10:48:07.962077-05:00","created_by":"daemon"},{"issue_id":"prt-bcw","depends_on_id":"prt-du2","type":"blocks","created_at":"2025-12-19T10:48:08.52011-05:00","created_by":"daemon"},{"issue_id":"prt-bcw","depends_on_id":"prt-c43","type":"blocks","created_at":"2025-12-19T10:48:09.090646-05:00","created_by":"daemon"},{"issue_id":"prt-bcw","depends_on_id":"prt-zib","type":"parent-child","created_at":"2025-12-19T11:00:53.751169-05:00","created_by":"daemon"}]}
{"id":"prt-bgs","title":"Write unit tests for model helpers","description":"## Task\nWrite comprehensive unit tests for all model helper methods.\n\n## Files to Test\n- internal/models/pr_test.go\n- internal/models/repo_test.go\n- internal/models/stack_test.go\n\n## PR Tests\n```go\nfunc TestPR_Age(t *testing.T) {\n    // Test various ages\n}\n\nfunc TestPR_AgeString(t *testing.T) {\n    // \u003c 1 hour -\u003e \"Xm ago\"\n    // 1-24 hours -\u003e \"Xh ago\"\n    // \u003e 24 hours -\u003e \"Xd ago\"\n}\n\nfunc TestPR_EffectiveState(t *testing.T) {\n    // IsDraft=true -\u003e DRAFT\n    // IsDraft=false -\u003e actual State\n}\n```\n\n## Repository Tests\n```go\nfunc TestRepository_FullName(t *testing.T) {\n    // Returns \"owner/name\"\n}\n\nfunc TestRepository_HasPRs(t *testing.T) {\n    // Empty slice -\u003e false\n    // Non-empty -\u003e true\n}\n```\n\n## Stack Tests\n```go\nfunc TestStackNode_IsBlocked(t *testing.T) {\n    // No parent -\u003e false\n    // Has parent, not orphan -\u003e true\n    // Orphan -\u003e false (parent merged)\n}\n\nfunc TestStackNode_GetRoot(t *testing.T) {\n    // Single node -\u003e returns self\n    // Chain -\u003e returns top parent\n}\n```\n\n## Test Strategy\nUse table-driven tests for comprehensive coverage:\n```go\ntests := []struct {\n    name     string\n    input    time.Time\n    expected string\n}{\n    {\"minutes\", time.Now().Add(-30*time.Minute), \"30m ago\"},\n    {\"hours\", time.Now().Add(-5*time.Hour), \"5h ago\"},\n    {\"days\", time.Now().Add(-3*24*time.Hour), \"3d ago\"},\n}\n```\n\n## Acceptance Criteria\n- [ ] All helper methods have tests\n- [ ] Edge cases covered\n- [ ] Tests pass\n- [ ] Coverage \u003e 90% for models package\n\n## Part of Epic\nData Models (prt-zib)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-19T10:38:08.159629-05:00","updated_at":"2025-12-19T10:38:08.159629-05:00","dependencies":[{"issue_id":"prt-bgs","depends_on_id":"prt-jn5","type":"blocks","created_at":"2025-12-19T10:48:13.926112-05:00","created_by":"daemon"},{"issue_id":"prt-bgs","depends_on_id":"prt-du2","type":"blocks","created_at":"2025-12-19T10:48:14.474148-05:00","created_by":"daemon"},{"issue_id":"prt-bgs","depends_on_id":"prt-c43","type":"blocks","created_at":"2025-12-19T10:48:15.131381-05:00","created_by":"daemon"},{"issue_id":"prt-bgs","depends_on_id":"prt-zib","type":"parent-child","created_at":"2025-12-19T11:00:54.371194-05:00","created_by":"daemon"}]}
{"id":"prt-bhq","title":"Repository Scanner","description":"## Overview\nDiscover Git repositories within user-configured paths. The scanner walks directories, identifies repos by .git folders, extracts GitHub remote info, and applies glob filters.\n\n## Why Directory Scanning?\nUsers work across many repos. Rather than manually listing each, they configure parent directories like `~/code/work` and PRT finds all repos within.\n\n## Components\n\n### Scanner (`internal/scanner/scanner.go`)\n- Walk configured search_paths\n- Respect scan_depth limit\n- Find .git directories\n- Build Repository objects\n\n### Filter (`internal/scanner/filter.go`)\n- Compile include_repos glob patterns\n- Match repo names against patterns\n- Empty patterns = match all\n\n### Git (`internal/scanner/git.go`)\n- Detect valid git repos\n- Parse remote URL (SSH and HTTPS formats)\n- Extract owner/repo from GitHub URLs\n\n## Directory Walking Rules\n1. Start at each search_path\n2. Track depth relative to search_path\n3. Stop descending when depth \u003e scan_depth\n4. Skip symlinks (avoid infinite loops)\n5. Skip hidden directories except .git\n6. Handle permission errors gracefully (skip, don't fail)\n\n## Remote URL Parsing\nMust handle:\n- `git@github.com:owner/repo.git`\n- `https://github.com/owner/repo.git`\n- `https://github.com/owner/repo` (no .git suffix)\n- `ssh://git@github.com/owner/repo.git`\n\nNon-GitHub remotes should be skipped (not an error).\n\n## Glob Pattern Matching\nUsing `github.com/gobwas/glob` for patterns like:\n- `myorg-*` - repos starting with myorg-\n- `*-api` - repos ending with -api\n- `frontend` - exact match\n\n## Performance Considerations\n- Don't stat every file, just directories\n- Skip common non-repo directories early (node_modules, .git contents, etc.)\n- Parallelize if needed (but directory walking is usually fast)\n\n## Acceptance Criteria\n- [ ] Finds repos at various depths\n- [ ] Respects scan_depth limit\n- [ ] Skips symlinks safely\n- [ ] Handles permission errors without crashing\n- [ ] Glob filtering works correctly\n- [ ] Parses SSH and HTTPS GitHub URLs\n- [ ] Ignores non-GitHub remotes\n- [ ] Unit tests with temp directories\n\n## Edge Cases\n- Repo with no origin remote -\u003e skip\n- Repo with non-GitHub remote -\u003e skip\n- Nested repos (repo inside repo) -\u003e find both\n- Broken symlinks -\u003e skip without error","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-19T10:33:09.629315-05:00","updated_at":"2025-12-19T11:02:20.071128-05:00"}
{"id":"prt-bn4","title":"Setup Wizard","description":"## Overview\nInteractive first-run wizard that creates ~/.prt/config.yaml with sensible defaults and user preferences.\n\n## When Triggered\n- Config file doesn't exist\n- Config file exists but is invalid\n- User explicitly runs setup (future: `prt init`)\n\n## Wizard Flow\n```\nWelcome to PRT (PR Tracker)! üöÄ\n\nLet's set up your configuration.\n\n? What is your GitHub username? (leave blank to auto-detect)\n\u003e jdoe\n\n‚úì Detected username: jdoe\n\n? Where should PRT look for repositories?\n  (Enter paths separated by commas, ~ supported)\n\u003e ~/code/work, ~/projects/oss\n\n‚úì Found 12 repositories in configured paths\n\n? Any repository name patterns to include? (glob syntax, blank for all)\n\u003e \n\n‚úì Will scan all repositories\n\n? Add team members? (GitHub usernames, comma-separated, blank to skip)\n\u003e sarah-dev, mike-frontend, tom-backend\n\n‚úì Added 3 team members\n\nConfiguration saved to ~/.prt/config.yaml\n\nRun `prt` to see your PR dashboard!\n```\n\n## Components\n- `internal/cli/wizard.go`: Interactive setup flow\n\n## Features\n\n### Username Auto-Detection\nIf user leaves blank, run `gh api user --jq .login` to get username.\nFail gracefully if gh not authenticated (prompt for manual entry).\n\n### Path Validation\nAfter entering paths:\n1. Expand ~ to home directory\n2. Check paths exist\n3. Quick scan to count repos found\n4. Show feedback: 'Found X repositories'\n\n### Pattern Preview\nIf user enters patterns, show which repos match:\n```\nPattern 'api-*' matches:\n  ‚Ä¢ api-gateway\n  ‚Ä¢ api-users\n  ‚Ä¢ api-billing\n3 repositories matched\n```\n\n### Team Member Validation\nOptionally validate team members are real GitHub users (via `gh api users/{name}`).\nSkip validation by default (might hit rate limits).\n\n## Output\nGenerate commented YAML:\n```yaml\n# PRT Configuration\n# Generated by setup wizard on 2024-12-19\n\ngithub_username: \"jdoe\"\n\nteam_members:\n  - \"sarah-dev\"\n  - \"mike-frontend\"\n\nsearch_paths:\n  - \"~/code/work\"\n  - \"~/projects/oss\"\n\n# ... rest of defaults with comments\n```\n\n## User Experience Principles\n- Minimal questions (only what's truly needed)\n- Smart defaults (pre-populated bot list, scan_depth=3)\n- Immediate feedback (validate as you go)\n- Easy to re-run (overwrite with confirmation)\n\n## Error Handling\n- Invalid path entered: Show error, prompt again\n- gh not available: Still allow setup, warn about authentication\n- Write permission error: Show clear error with instructions\n\n## Acceptance Criteria\n- [ ] Wizard runs on first launch (no config)\n- [ ] Username auto-detection works\n- [ ] Paths expanded and validated\n- [ ] Team members saved correctly\n- [ ] Generated YAML is valid and commented\n- [ ] Wizard can be skipped (--no-wizard flag?)\n- [ ] Re-running wizard prompts for overwrite\n- [ ] Unit tests for input parsing","status":"open","priority":2,"issue_type":"epic","created_at":"2025-12-19T10:35:04.027014-05:00","updated_at":"2025-12-19T11:02:20.075345-05:00"}
{"id":"prt-c43","title":"Implement Stack models","description":"## Task\nCreate the Stack and StackNode models for representing PR dependency trees.\n\n## File: internal/models/stack.go\n\n## StackNode\n```go\ntype StackNode struct {\n    PR       *PR\n    Parent   *StackNode   `json:\"-\"`  // Avoid circular JSON\n    Children []*StackNode\n    \n    // Stack metadata\n    Depth    int   // 0 = root\n    IsOrphan bool  // Parent was merged\n}\n```\n\n## Stack\n```go\ntype Stack struct {\n    Roots    []*StackNode  // PRs with no parent in set\n    AllNodes []*StackNode  // Flattened for easy iteration\n}\n```\n\n## Helper Methods on StackNode\n- `IsBlocked() bool`: Returns true if has unmerged parent\n- `GetRoot() *StackNode`: Walks up to find stack root\n\n## Design Notes\n- Parent pointer is excluded from JSON to avoid circular references\n- Depth is computed during tree building\n- IsOrphan indicates the parent PR merged but this PR still targets that branch\n- Multiple roots possible (independent stacks in same repo)\n\n## Acceptance Criteria\n- [ ] StackNode struct compiles\n- [ ] Stack struct compiles\n- [ ] Helper methods work correctly\n- [ ] JSON serialization doesn't cause infinite loop\n- [ ] Unit tests for IsBlocked(), GetRoot()\n\n## Part of Epic\nData Models (prt-zib)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-19T10:38:02.581282-05:00","updated_at":"2025-12-19T10:38:02.581282-05:00","dependencies":[{"issue_id":"prt-c43","depends_on_id":"prt-mt5","type":"blocks","created_at":"2025-12-19T10:48:04.175692-05:00","created_by":"daemon"},{"issue_id":"prt-c43","depends_on_id":"prt-zib","type":"parent-child","created_at":"2025-12-19T11:00:53.194408-05:00","created_by":"daemon"}]}
{"id":"prt-ciu","title":"Initialize Go module","description":"## Task\nInitialize the Go module with `prt` as the module name.\n\n## Why 'prt' and not 'github.com/ChrisEdwards/prt'?\nFollowing the convention from the abacus project - CLI tools distributed as binaries don't need the full GitHub path. That path is only necessary when the code will be imported as a library by other Go projects.\n\n## Steps\n1. Run `go mod init prt`\n2. Verify go.mod created with correct module name\n3. Run `go mod tidy` (will be empty initially)\n\n## Acceptance Criteria\n- [ ] go.mod exists with `module prt`\n- [ ] Go version set to 1.21 or higher\n\n## Part of Epic\nProject Foundation \u0026 Scaffolding (prt-ai4)","status":"in_progress","priority":1,"issue_type":"task","created_at":"2025-12-19T10:36:09.086154-05:00","updated_at":"2025-12-19T12:56:20.677729-05:00","dependencies":[{"issue_id":"prt-ciu","depends_on_id":"prt-ai4","type":"parent-child","created_at":"2025-12-19T11:00:12.063486-05:00","created_by":"daemon"}]}
{"id":"prt-clj","title":"Implement stack detection algorithm","description":"## Task\nDetect parent-child relationships between PRs (stacked PRs).\n\n## File: internal/stacks/detector.go\n\n## Algorithm\nA PR is a \"child\" of another PR if its base branch equals the parent's head branch:\n```\nPR_A: feature-auth -\u003e main (head=feature-auth, base=main)\nPR_B: feature-auth-tests -\u003e feature-auth (head=feature-auth-tests, base=feature-auth)\n\nSince PR_B.base == PR_A.head:\n  PR_B is a child of PR_A\n  PR_A is the parent of PR_B\n```\n\n## Implementation\n```go\nfunc DetectStacks(prs []*models.PR) *models.Stack {\n    if len(prs) == 0 {\n        return \u0026models.Stack{}\n    }\n    \n    // Map: headBranch -\u003e PR\n    headBranchToPR := make(map[string]*models.PR)\n    for _, pr := range prs {\n        headBranchToPR[pr.HeadBranch] = pr\n    }\n    \n    // Create nodes for all PRs\n    nodes := make(map[int]*models.StackNode)\n    for _, pr := range prs {\n        nodes[pr.Number] = \u0026models.StackNode{\n            PR:       pr,\n            Children: []*models.StackNode{},\n        }\n    }\n    \n    // Build parent-child relationships\n    for _, pr := range prs {\n        // Is there a PR whose head branch is our base branch?\n        if parentPR, ok := headBranchToPR[pr.BaseBranch]; ok {\n            parentNode := nodes[parentPR.Number]\n            childNode := nodes[pr.Number]\n            \n            childNode.Parent = parentNode\n            parentNode.Children = append(parentNode.Children, childNode)\n        }\n    }\n    \n    // Find roots (nodes with no parent)\n    var roots []*models.StackNode\n    var allNodes []*models.StackNode\n    \n    for _, node := range nodes {\n        allNodes = append(allNodes, node)\n        if node.Parent == nil {\n            roots = append(roots, node)\n        }\n    }\n    \n    // Calculate depths\n    for _, root := range roots {\n        setDepths(root, 0)\n    }\n    \n    // Sort roots by PR number for consistent ordering\n    sort.Slice(roots, func(i, j int) bool {\n        return roots[i].PR.Number \u003c roots[j].PR.Number\n    })\n    \n    return \u0026models.Stack{\n        Roots:    roots,\n        AllNodes: allNodes,\n    }\n}\n\nfunc setDepths(node *models.StackNode, depth int) {\n    node.Depth = depth\n    for _, child := range node.Children {\n        setDepths(child, depth+1)\n    }\n}\n```\n\n## Edge Cases\n1. **No stacks**: All PRs target main -\u003e all are roots\n2. **Single stack**: Linear chain A -\u003e B -\u003e C\n3. **Diamond**: Two children of same parent\n4. **Multiple stacks**: Independent trees in same repo\n5. **Deep stacks**: 5+ levels (rare but valid)\n\n## Acceptance Criteria\n- [ ] Detects simple parent-child\n- [ ] Builds correct tree structure\n- [ ] Handles multiple independent stacks\n- [ ] Handles diamond patterns\n- [ ] Calculates depths correctly\n- [ ] Unit tests for all edge cases\n\n## Part of Epic\nStack Detection Algorithm (prt-x7j)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-19T10:43:58.580378-05:00","updated_at":"2025-12-19T10:43:58.580378-05:00","dependencies":[{"issue_id":"prt-clj","depends_on_id":"prt-c43","type":"blocks","created_at":"2025-12-19T10:49:49.887411-05:00","created_by":"daemon"},{"issue_id":"prt-clj","depends_on_id":"prt-x7j","type":"parent-child","created_at":"2025-12-19T11:01:36.742016-05:00","created_by":"daemon"}]}
{"id":"prt-du2","title":"Implement Repository model","description":"## Task\nCreate the Repository domain model representing a local Git repository.\n\n## File: internal/models/repo.go\n\n## Fields\n```go\ntype Repository struct {\n    Name       string         // e.g., \"prt\"\n    Path       string         // e.g., \"/Users/jdoe/code/prt\"\n    RemoteURL  string         // e.g., \"git@github.com:org/prt.git\"\n    Owner      string         // e.g., \"org\"\n    PRs        []*PR\n    \n    // Scan metadata\n    ScanError  error         // Non-nil if scan failed\n    ScanStatus ScanStatus\n}\n\ntype ScanStatus string\n\nconst (\n    ScanStatusSuccess   ScanStatus = \"success\"\n    ScanStatusNoPRs     ScanStatus = \"no_prs\"\n    ScanStatusError     ScanStatus = \"error\"\n    ScanStatusSkipped   ScanStatus = \"skipped\"\n)\n```\n\n## Helper Methods\n- `FullName() string`: Returns \"owner/name\"\n- `HasPRs() bool`: Returns len(PRs) \u003e 0\n\n## Design Notes\n- ScanError is not JSON serialized (error interface doesn't marshal well)\n- ScanStatus provides serializable scan result info\n- PRs slice is populated after GitHub fetch\n\n## Acceptance Criteria\n- [ ] Repository struct compiles\n- [ ] ScanStatus enum defined\n- [ ] Helper methods work\n- [ ] JSON serialization correct (error excluded)\n\n## Part of Epic\nData Models (prt-zib)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-19T10:38:01.418589-05:00","updated_at":"2025-12-19T10:38:01.418589-05:00","dependencies":[{"issue_id":"prt-du2","depends_on_id":"prt-mt5","type":"blocks","created_at":"2025-12-19T10:48:03.626416-05:00","created_by":"daemon"},{"issue_id":"prt-du2","depends_on_id":"prt-zib","type":"parent-child","created_at":"2025-12-19T11:00:52.551646-05:00","created_by":"daemon"}]}
{"id":"prt-e31","title":"Implement config loading with Viper","description":"## Task\nImplement the config loading function using Viper with proper precedence.\n\n## File: internal/config/config.go\n\n## Precedence (highest to lowest)\n1. CLI flags\n2. Environment variables (PRT_* prefix)\n3. Config file (~/.prt/config.yaml)\n4. Hardcoded defaults\n\n## Implementation\n```go\ntype Flags struct {\n    Path   string\n    Filter string\n    Group  string\n    Depth  int\n    JSON   bool\n    NoColor bool\n}\n\nfunc Load(flags *Flags) (*Config, error) {\n    v := viper.New()\n    \n    // 1. Set defaults\n    v.SetDefault(\"scan_depth\", DefaultConfig.ScanDepth)\n    v.SetDefault(\"default_group_by\", DefaultConfig.DefaultGroupBy)\n    v.SetDefault(\"default_sort\", DefaultConfig.DefaultSort)\n    v.SetDefault(\"show_branch_name\", DefaultConfig.ShowBranchName)\n    v.SetDefault(\"show_icons\", DefaultConfig.ShowIcons)\n    v.SetDefault(\"bots\", DefaultConfig.Bots)\n    \n    // 2. Load config file\n    v.SetConfigName(\"config\")\n    v.SetConfigType(\"yaml\")\n    v.AddConfigPath(ConfigDir())\n    \n    if err := v.ReadInConfig(); err != nil {\n        if _, ok := err.(viper.ConfigFileNotFoundError); !ok {\n            return nil, fmt.Errorf(\"error reading config: %w\", err)\n        }\n        // Config not found - will trigger wizard\n    }\n    \n    // 3. Environment variables\n    v.SetEnvPrefix(\"PRT\")\n    v.AutomaticEnv()\n    v.SetEnvKeyReplacer(strings.NewReplacer(\".\", \"_\"))\n    \n    // 4. CLI flag overrides\n    if flags != nil {\n        if flags.Path != \"\" {\n            v.Set(\"search_paths\", []string{flags.Path})\n        }\n        if flags.Depth \u003e 0 {\n            v.Set(\"scan_depth\", flags.Depth)\n        }\n        if flags.Group != \"\" {\n            v.Set(\"default_group_by\", flags.Group)\n        }\n    }\n    \n    // 5. Unmarshal\n    var cfg Config\n    if err := v.Unmarshal(\u0026cfg); err != nil {\n        return nil, err\n    }\n    \n    // 6. Expand paths\n    cfg.SearchPaths = expandPaths(cfg.SearchPaths)\n    \n    return \u0026cfg, nil\n}\n\nfunc expandPaths(paths []string) []string {\n    result := make([]string, 0, len(paths))\n    for _, p := range paths {\n        if strings.HasPrefix(p, \"~\") {\n            home, _ := os.UserHomeDir()\n            p = filepath.Join(home, p[1:])\n        }\n        result = append(result, p)\n    }\n    return result\n}\n```\n\n## Environment Variables\nUsers can set:\n- PRT_GITHUB_USERNAME\n- PRT_SCAN_DEPTH\n- etc.\n\n## Acceptance Criteria\n- [ ] Config loads from file\n- [ ] Missing file doesn't error (returns defaults)\n- [ ] CLI flags override config values\n- [ ] Environment variables work\n- [ ] Paths are expanded (~ -\u003e home)\n\n## Part of Epic\nConfiguration System (prt-v3f)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-19T10:39:25.752855-05:00","updated_at":"2025-12-19T10:39:25.752855-05:00","dependencies":[{"issue_id":"prt-e31","depends_on_id":"prt-5eu","type":"blocks","created_at":"2025-12-19T10:48:49.736434-05:00","created_by":"daemon"},{"issue_id":"prt-e31","depends_on_id":"prt-7r8","type":"blocks","created_at":"2025-12-19T10:48:50.254865-05:00","created_by":"daemon"},{"issue_id":"prt-e31","depends_on_id":"prt-v3f","type":"parent-child","created_at":"2025-12-19T11:01:05.159859-05:00","created_by":"daemon"}]}
{"id":"prt-e4a","title":"Concurrent PR Fetching \u0026 Orchestration","description":"## Overview\nFetch PRs from all discovered repositories concurrently using goroutines. This is critical for performance - sequential fetching would be painfully slow with many repos.\n\n## Why Concurrency Matters\nEach `gh pr list` call takes 0.5-2 seconds (network latency). With 20 repos:\n- Sequential: 20-40 seconds\n- Concurrent: 2-3 seconds (limited by slowest repo)\n\n## Architecture\n\n### Orchestrator Pattern\n```go\nfunc FetchAllPRs(repos []*Repository, client Client, progress func(done, total int)) ([]*Repository, error) {\n    results := make(chan *Repository, len(repos))\n    \n    for _, repo := range repos {\n        go func(r *Repository) {\n            prs, err := client.ListPRs(r.Path)\n            r.PRs = prs\n            r.ScanError = err\n            results \u003c- r\n        }(repo)\n    }\n    \n    for i := 0; i \u003c len(repos); i++ {\n        \u003c-results\n        progress(i+1, len(repos))\n    }\n}\n```\n\n### Progress Callback\nThe orchestrator accepts a progress callback for UI updates:\n- Called after each repo completes\n- Provides done count and total count\n- Display layer uses this for progress bar\n\n### Partial Failure Handling\n- Individual repo failures should NOT abort the entire scan\n- Store error in repo.ScanError\n- Continue fetching other repos\n- Report errors in summary at end\n\n## Concurrency Limits\nConsider adding a semaphore to limit concurrent requests:\n- Prevents overwhelming GitHub API\n- Avoids rate limiting\n- Suggested limit: 10 concurrent requests\n\n## Components\n- `internal/github/orchestrator.go`: FetchAllPRs function\n- Progress callback type definition\n- Result aggregation logic\n\n## Acceptance Criteria\n- [ ] PRs fetched concurrently (not sequentially)\n- [ ] Progress callback invoked after each repo\n- [ ] Individual repo errors don't abort scan\n- [ ] Errors stored in repo.ScanError\n- [ ] Total time is ~max(individual times), not sum\n- [ ] Integration tests verify concurrent behavior\n\n## Testing Strategy\n- Mock the GitHub client\n- Use timing assertions to verify concurrency\n- Test partial failure scenarios\n- Test progress callback invocation","status":"open","priority":2,"issue_type":"epic","created_at":"2025-12-19T10:33:10.641152-05:00","updated_at":"2025-12-19T11:02:20.071819-05:00"}
{"id":"prt-ee6","title":"Implement remote URL parsing for GitHub repos","description":"## Task\nParse Git remote URLs to extract GitHub owner and repository name.\n\n## File: internal/scanner/git.go\n\n## URL Formats to Handle\n```\nSSH:\n  git@github.com:owner/repo.git\n  git@github.com:owner/repo\n  ssh://git@github.com/owner/repo.git\n\nHTTPS:\n  https://github.com/owner/repo.git\n  https://github.com/owner/repo\n  http://github.com/owner/repo.git\n```\n\n## Implementation\n```go\nvar (\n    // SSH format: git@github.com:owner/repo.git\n    sshRegex = regexp.MustCompile(`^git@github\\.com:([^/]+)/([^/]+?)(\\.git)?$`)\n    \n    // HTTPS format: https://github.com/owner/repo.git\n    httpsRegex = regexp.MustCompile(`^https?://github\\.com/([^/]+)/([^/]+?)(\\.git)?$`)\n    \n    // SSH URL format: ssh://git@github.com/owner/repo.git\n    sshURLRegex = regexp.MustCompile(`^ssh://git@github\\.com/([^/]+)/([^/]+?)(\\.git)?$`)\n)\n\nfunc parseGitHubRemote(remoteURL string) (owner, repo string) {\n    remoteURL = strings.TrimSpace(remoteURL)\n    \n    // Try SSH format\n    if matches := sshRegex.FindStringSubmatch(remoteURL); len(matches) \u003e= 3 {\n        return matches[1], matches[2]\n    }\n    \n    // Try HTTPS format\n    if matches := httpsRegex.FindStringSubmatch(remoteURL); len(matches) \u003e= 3 {\n        return matches[1], matches[2]\n    }\n    \n    // Try SSH URL format\n    if matches := sshURLRegex.FindStringSubmatch(remoteURL); len(matches) \u003e= 3 {\n        return matches[1], matches[2]\n    }\n    \n    // Not a GitHub remote\n    return \"\", \"\"\n}\n```\n\n## Get Remote URL\n```go\nfunc getRemoteURL(repoPath string) (string, error) {\n    cmd := exec.Command(\"git\", \"remote\", \"get-url\", \"origin\")\n    cmd.Dir = repoPath\n    \n    out, err := cmd.Output()\n    if err \\!= nil {\n        return \"\", fmt.Errorf(\"no origin remote: %w\", err)\n    }\n    \n    return strings.TrimSpace(string(out)), nil\n}\n```\n\n## Inspect Repository\n```go\nfunc (s *scanner) inspectRepo(path string) (*models.Repository, error) {\n    remoteURL, err := getRemoteURL(path)\n    if err \\!= nil {\n        return nil, err\n    }\n    \n    owner, name := parseGitHubRemote(remoteURL)\n    if owner == \"\" || name == \"\" {\n        return nil, fmt.Errorf(\"not a GitHub repository: %s\", remoteURL)\n    }\n    \n    return \u0026models.Repository{\n        Name:      name,\n        Path:      path,\n        RemoteURL: remoteURL,\n        Owner:     owner,\n    }, nil\n}\n```\n\n## Non-GitHub Repos\nRepos with non-GitHub remotes (GitLab, Bitbucket, etc.) return empty owner/name and are skipped. This is not an error - we just don't process them.\n\n## Acceptance Criteria\n- [ ] Parses SSH format correctly\n- [ ] Parses HTTPS format correctly  \n- [ ] Handles .git suffix (present or absent)\n- [ ] Returns empty for non-GitHub repos\n- [ ] Unit tests for all URL formats\n\n## Part of Epic\nRepository Scanner (prt-bhq)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-19T10:42:31.084327-05:00","updated_at":"2025-12-19T10:42:31.084327-05:00","dependencies":[{"issue_id":"prt-ee6","depends_on_id":"prt-mt5","type":"blocks","created_at":"2025-12-19T10:49:33.841703-05:00","created_by":"daemon"},{"issue_id":"prt-ee6","depends_on_id":"prt-bhq","type":"parent-child","created_at":"2025-12-19T11:01:33.595543-05:00","created_by":"daemon"}]}
{"id":"prt-jn5","title":"Implement PR model","description":"## Task\nCreate the PR (Pull Request) domain model.\n\n## File: internal/models/pr.go\n\n## Fields\n```go\ntype PR struct {\n    // Identity\n    Number int\n    Title  string\n    URL    string\n    \n    // Authorship\n    Author string\n    \n    // State\n    State   PRState\n    IsDraft bool\n    \n    // Branches\n    BaseBranch string  // Target (e.g., \"main\")\n    HeadBranch string  // Source (e.g., \"feature-x\")\n    \n    // Timestamps\n    CreatedAt time.Time\n    \n    // CI Status\n    CIStatus CIStatus\n    \n    // Review Information\n    ReviewRequests []string\n    Assignees      []string\n    Reviews        []Review\n    \n    // Computed (set during categorization)\n    IsReviewRequestedFromMe bool\n    IsAssignedToMe          bool\n    MyReviewStatus          ReviewState\n    \n    // Repository context (set during aggregation)\n    RepoName  string\n    RepoPath  string\n}\n```\n\n## Enums\n- PRState: OPEN, DRAFT, MERGED, CLOSED\n- CIStatus: passing, failing, pending, none\n- ReviewState: NONE, APPROVED, CHANGES_REQUESTED, COMMENTED, PENDING, DISMISSED\n\n## Review Struct\n```go\ntype Review struct {\n    Author    string\n    State     ReviewState\n    Submitted time.Time\n}\n```\n\n## Helper Methods\n- `Age() time.Duration`: Time since creation\n- `AgeString() string`: Human-readable age (\"2d ago\", \"5h ago\")\n- `EffectiveState() PRState`: Returns DRAFT if IsDraft, else State\n\n## JSON Tags\nInclude `json:`tags for all exported fields (needed for --json output).\n\n## Acceptance Criteria\n- [ ] PR struct compiles\n- [ ] All enums defined as typed strings\n- [ ] Review struct defined\n- [ ] Helper methods implemented\n- [ ] Unit tests for Age(), AgeString()\n\n## Part of Epic\nData Models (prt-zib)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-19T10:38:00.4062-05:00","updated_at":"2025-12-19T10:38:00.4062-05:00","dependencies":[{"issue_id":"prt-jn5","depends_on_id":"prt-mt5","type":"blocks","created_at":"2025-12-19T10:48:03.067403-05:00","created_by":"daemon"},{"issue_id":"prt-jn5","depends_on_id":"prt-zib","type":"parent-child","created_at":"2025-12-19T11:00:51.923665-05:00","created_by":"daemon"}]}
{"id":"prt-krw","title":"Define lipgloss styles","description":"## Task\nDefine all terminal styling using the lipgloss library.\n\n## File: internal/display/styles.go\n\n## Style Definitions\n```go\npackage display\n\nimport \"github.com/charmbracelet/lipgloss\"\n\nvar (\n    // Section headers\n    HeaderStyle = lipgloss.NewStyle().\n        Bold(true).\n        Foreground(lipgloss.Color(\"15\")).  // White\n        Background(lipgloss.Color(\"57\")).  // Purple\n        Padding(0, 1)\n    \n    SubheaderStyle = lipgloss.NewStyle().\n        Bold(true).\n        Foreground(lipgloss.Color(\"244\")) // Gray\n    \n    // PR States\n    DraftStyle = lipgloss.NewStyle().\n        Foreground(lipgloss.Color(\"244\")). // Gray\n        Italic(true)\n    \n    NeedsReviewStyle = lipgloss.NewStyle().\n        Foreground(lipgloss.Color(\"46\")) // Green\n    \n    ApprovedStyle = lipgloss.NewStyle().\n        Foreground(lipgloss.Color(\"39\")) // Blue\n    \n    ChangesRequestedStyle = lipgloss.NewStyle().\n        Foreground(lipgloss.Color(\"214\")) // Orange\n    \n    BlockedStyle = lipgloss.NewStyle().\n        Foreground(lipgloss.Color(\"244\")). // Gray\n        Faint(true)\n    \n    // CI Status\n    CIPassingStyle = lipgloss.NewStyle().\n        Foreground(lipgloss.Color(\"46\")) // Green\n    \n    CIFailingStyle = lipgloss.NewStyle().\n        Foreground(lipgloss.Color(\"196\")) // Red\n    \n    CIPendingStyle = lipgloss.NewStyle().\n        Foreground(lipgloss.Color(\"226\")) // Yellow\n    \n    // URLs\n    URLStyle = lipgloss.NewStyle().\n        Foreground(lipgloss.Color(\"39\")). // Blue\n        Underline(true)\n    \n    // Tree\n    TreeStyle = lipgloss.NewStyle().\n        Foreground(lipgloss.Color(\"240\")) // Dark gray\n    \n    // Empty state\n    EmptyStyle = lipgloss.NewStyle().\n        Foreground(lipgloss.Color(\"244\")).\n        Italic(true)\n    \n    // Meta info\n    MetaStyle = lipgloss.NewStyle().\n        Foreground(lipgloss.Color(\"244\"))\n    \n    // Repo name\n    RepoStyle = lipgloss.NewStyle().\n        Bold(true).\n        Foreground(lipgloss.Color(\"39\")) // Blue\n)\n```\n\n## Icons\n```go\nconst (\n    IconPR        = \"üìã\"\n    IconDraft     = \"üìù\"\n    IconMerged    = \"üü£\"\n    IconApproved  = \"‚úÖ\"\n    IconChanges   = \"üîÑ\"\n    IconReview    = \"üëÄ\"\n    IconBlocked   = \"üîí\"\n    IconCIPassing = \"‚úÖ\"\n    IconCIFailing = \"‚ùå\"\n    IconCIPending = \"‚è≥\"\n    IconRepo      = \"üì¶\"\n    IconTeam      = \"üë•\"\n    IconBot       = \"ü§ñ\"\n    IconEmpty     = \"‚àÖ\"\n    \n    // Tree characters\n    TreeVertical   = \"‚îÇ\"\n    TreeBranch     = \"‚îú‚îÄ‚îÄ\"\n    TreeLastBranch = \"‚îî‚îÄ‚îÄ\"\n    TreeIndent     = \"    \"\n)\n```\n\n## No-Color Mode\n```go\nfunc DisableColors() {\n    lipgloss.SetColorProfile(lipgloss.Ascii)\n}\n```\n\n## Acceptance Criteria\n- [ ] All styles defined\n- [ ] Icons defined as constants\n- [ ] Tree characters defined\n- [ ] DisableColors() works\n- [ ] Colors look good in terminal\n\n## Part of Epic\nDisplay System (prt-75i)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-19T10:45:13.489045-05:00","updated_at":"2025-12-19T10:45:13.489045-05:00","dependencies":[{"issue_id":"prt-krw","depends_on_id":"prt-mt5","type":"blocks","created_at":"2025-12-19T10:50:16.968881-05:00","created_by":"daemon"},{"issue_id":"prt-krw","depends_on_id":"prt-75i","type":"parent-child","created_at":"2025-12-19T11:01:50.263775-05:00","created_by":"daemon"}]}
{"id":"prt-ln4","title":"Implement ListPRs for single repository","description":"## Task\nImplement fetching PRs for a single repository.\n\n## File: internal/github/client.go\n\n## Client Structure\n```go\ntype Client interface {\n    Check() error\n    GetCurrentUser() (string, error)\n    ListPRs(repoPath string) ([]*models.PR, error)\n}\n\ntype client struct {\n    retryConfig RetryConfig\n}\n\nfunc NewClient(cfg RetryConfig) Client {\n    return \u0026client{retryConfig: cfg}\n}\n```\n\n## ListPRs Implementation\n```go\nfunc (c *client) ListPRs(repoPath string) ([]*models.PR, error) {\n    return c.withRetry(func() ([]*models.PR, error) {\n        cmd := exec.Command(\"gh\", \"pr\", \"list\",\n            \"--json\", \"number,title,url,author,state,isDraft,createdAt,baseRefName,headRefName,statusCheckRollup,reviewRequests,assignees,reviews\",\n            \"--state\", \"open\",\n        )\n        cmd.Dir = repoPath\n        \n        out, err := cmd.Output()\n        if err \\!= nil {\n            return nil, classifyError(err, repoPath)\n        }\n        \n        // Empty output means no PRs\n        if len(out) == 0 || string(out) == \"[]\\n\" || string(out) == \"[]\" {\n            return []*models.PR{}, nil\n        }\n        \n        return ParsePRList(out)\n    })\n}\n```\n\n## Key Details\n- `cmd.Dir = repoPath`: Execute gh in the repo directory\n- `--state open`: Only fetch open PRs (drafts are included)\n- Handle empty responses (no PRs)\n- Apply retry logic\n- Classify errors appropriately\n\n## Why Execute in Repo Directory?\n`gh pr list` uses the current directory's git remote to determine which repo to query. This is simpler than specifying owner/repo explicitly.\n\n## Acceptance Criteria\n- [ ] Fetches PRs for a repository\n- [ ] Handles repos with no PRs\n- [ ] Applies retry logic\n- [ ] Classifies errors correctly\n- [ ] Unit tests with mocked exec\n\n## Part of Epic\nGitHub CLI Integration (prt-749)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-19T10:41:27.265665-05:00","updated_at":"2025-12-19T10:41:27.265665-05:00","dependencies":[{"issue_id":"prt-ln4","depends_on_id":"prt-2ll","type":"blocks","created_at":"2025-12-19T10:49:08.489272-05:00","created_by":"daemon"},{"issue_id":"prt-ln4","depends_on_id":"prt-szp","type":"blocks","created_at":"2025-12-19T10:49:09.067225-05:00","created_by":"daemon"},{"issue_id":"prt-ln4","depends_on_id":"prt-a56","type":"blocks","created_at":"2025-12-19T10:49:09.700797-05:00","created_by":"daemon"},{"issue_id":"prt-ln4","depends_on_id":"prt-749","type":"parent-child","created_at":"2025-12-19T11:01:18.823177-05:00","created_by":"daemon"}]}
{"id":"prt-mt5","title":"Create project directory structure","description":"## Task\nCreate the directory structure as specified in the implementation spec.\n\n## Structure\n```\nprt/\n‚îú‚îÄ‚îÄ cmd/\n‚îÇ   ‚îî‚îÄ‚îÄ prt/\n‚îÇ       ‚îî‚îÄ‚îÄ main.go\n‚îú‚îÄ‚îÄ internal/\n‚îÇ   ‚îú‚îÄ‚îÄ cli/\n‚îÇ   ‚îú‚îÄ‚îÄ config/\n‚îÇ   ‚îú‚îÄ‚îÄ github/\n‚îÇ   ‚îú‚îÄ‚îÄ scanner/\n‚îÇ   ‚îú‚îÄ‚îÄ stacks/\n‚îÇ   ‚îú‚îÄ‚îÄ categorizer/\n‚îÇ   ‚îú‚îÄ‚îÄ display/\n‚îÇ   ‚îî‚îÄ‚îÄ models/\n‚îú‚îÄ‚îÄ go.mod\n‚îú‚îÄ‚îÄ go.sum\n‚îú‚îÄ‚îÄ Makefile\n‚îî‚îÄ‚îÄ README.md\n```\n\n## Why internal/?\nGo's `internal` directory prevents external packages from importing these packages. This is intentional - PRT is a CLI tool, not a library.\n\n## Steps\n1. Create all directories\n2. Add .gitkeep or placeholder files to ensure directories are tracked\n3. Verify structure matches spec\n\n## Acceptance Criteria\n- [ ] All directories exist\n- [ ] Structure matches implementation spec\n- [ ] Directories are tracked in git\n\n## Part of Epic\nProject Foundation \u0026 Scaffolding (prt-ai4)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-19T10:36:10.130155-05:00","updated_at":"2025-12-19T10:36:10.130155-05:00","dependencies":[{"issue_id":"prt-mt5","depends_on_id":"prt-ciu","type":"blocks","created_at":"2025-12-19T10:47:52.765076-05:00","created_by":"daemon"},{"issue_id":"prt-mt5","depends_on_id":"prt-ai4","type":"parent-child","created_at":"2025-12-19T11:00:12.6787-05:00","created_by":"daemon"}]}
{"id":"prt-rcx","title":"Implement section rendering","description":"## Task\nImplement rendering for each output section (My PRs, Needs Attention, etc.).\n\n## File: internal/display/sections.go\n\n## Section Headers\n```go\nfunc RenderSectionHeader(icon, title string, showIcons bool) string {\n    if showIcons {\n        return HeaderStyle.Render(fmt.Sprintf(\"%s %s\", icon, title))\n    }\n    return HeaderStyle.Render(title)\n}\n```\n\n## Full Section\n```go\nfunc RenderSection(title string, icon string, prs []*models.PR, stacks map[string]*models.Stack, showIcons bool, showBranches bool) string {\n    var b strings.Builder\n    \n    // Header\n    b.WriteString(RenderSectionHeader(icon, title, showIcons))\n    b.WriteString(\"\\n\\n\")\n    \n    // Empty state\n    if len(prs) == 0 {\n        if title == \"NEEDS MY ATTENTION\" {\n            b.WriteString(EmptyStyle.Render(\"  None - you're all caught up! üéâ\"))\n        } else {\n            b.WriteString(EmptyStyle.Render(\"  None\"))\n        }\n        b.WriteString(\"\\n\")\n        return b.String()\n    }\n    \n    // Group by repo\n    byRepo := groupByRepo(prs)\n    repoNames := sortedRepoNames(byRepo)\n    \n    for _, repoName := range repoNames {\n        repoPRs := byRepo[repoName]\n        \n        // Repo header\n        b.WriteString(\"  \")\n        b.WriteString(RepoStyle.Render(repoName))\n        b.WriteString(\"\\n\")\n        \n        // Render PRs (with stack awareness)\n        stack := stacks[repoName]\n        renderPRs(\u0026b, repoPRs, stack, showIcons, showBranches)\n        \n        b.WriteString(\"\\n\")\n    }\n    \n    return b.String()\n}\n```\n\n## Grouping\n```go\nfunc groupByRepo(prs []*models.PR) map[string][]*models.PR {\n    result := make(map[string][]*models.PR)\n    for _, pr := range prs {\n        result[pr.RepoName] = append(result[pr.RepoName], pr)\n    }\n    return result\n}\n\nfunc sortedRepoNames(byRepo map[string][]*models.PR) []string {\n    names := make([]string, 0, len(byRepo))\n    for name := range byRepo {\n        names = append(names, name)\n    }\n    sort.Strings(names)\n    return names\n}\n```\n\n## Acceptance Criteria\n- [ ] Section headers render correctly\n- [ ] Empty states handled\n- [ ] PRs grouped by repository\n- [ ] Repository names sorted\n- [ ] Icons optional\n\n## Part of Epic\nDisplay System (prt-75i)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-19T10:45:14.489126-05:00","updated_at":"2025-12-19T10:45:14.489126-05:00","dependencies":[{"issue_id":"prt-rcx","depends_on_id":"prt-krw","type":"blocks","created_at":"2025-12-19T10:50:17.572756-05:00","created_by":"daemon"},{"issue_id":"prt-rcx","depends_on_id":"prt-75i","type":"parent-child","created_at":"2025-12-19T11:01:50.830355-05:00","created_by":"daemon"}]}
{"id":"prt-s8o","title":"Write GitHub integration unit tests","description":"## Task\nWrite comprehensive unit tests for the GitHub integration package.\n\n## Files\n- internal/github/client_test.go\n- internal/github/parser_test.go\n- internal/github/retry_test.go\n\n## Testing Strategy\nUse exec mocking to avoid hitting real GitHub API.\n\n## Client Tests\n```go\nfunc TestClient_Check_GHNotFound(t *testing.T) {\n    // Mock LookPath to return error\n    // Verify GHNotFoundError returned\n}\n\nfunc TestClient_Check_NotAuthenticated(t *testing.T) {\n    // Mock gh auth status to return error\n    // Verify GHAuthError returned\n}\n\nfunc TestClient_Check_Success(t *testing.T) {\n    // Mock both to succeed\n    // Verify nil error\n}\n\nfunc TestClient_GetCurrentUser(t *testing.T) {\n    // Mock gh api user output\n    // Verify username extracted\n}\n\nfunc TestClient_ListPRs_Success(t *testing.T) {\n    // Mock gh pr list with sample JSON\n    // Verify PRs parsed correctly\n}\n\nfunc TestClient_ListPRs_NoPRs(t *testing.T) {\n    // Mock empty response\n    // Verify empty slice, no error\n}\n\nfunc TestClient_ListPRs_Error(t *testing.T) {\n    // Mock error response\n    // Verify error classified correctly\n}\n```\n\n## Parser Tests\n```go\nconst samplePRJSON = `[{\n  \"number\": 123,\n  \"title\": \"Test PR\",\n  \"author\": {\"login\": \"jdoe\"},\n  ...\n}]`\n\nfunc TestParsePRList_ValidJSON(t *testing.T) {\n    prs, err := ParsePRList([]byte(samplePRJSON))\n    require.NoError(t, err)\n    require.Len(t, prs, 1)\n    assert.Equal(t, 123, prs[0].Number)\n}\n\nfunc TestParsePRList_Empty(t *testing.T) {\n    prs, err := ParsePRList([]byte(\"[]\"))\n    require.NoError(t, err)\n    assert.Empty(t, prs)\n}\n\nfunc TestParsePRList_InvalidJSON(t *testing.T) {\n    _, err := ParsePRList([]byte(\"not json\"))\n    assert.Error(t, err)\n}\n\nfunc TestComputeCIStatus_AllPassing(t *testing.T) {}\nfunc TestComputeCIStatus_SomeFailing(t *testing.T) {}\nfunc TestComputeCIStatus_SomePending(t *testing.T) {}\nfunc TestComputeCIStatus_NoChecks(t *testing.T) {}\n```\n\n## Retry Tests\n```go\nfunc TestRetry_SuccessOnFirstAttempt(t *testing.T) {}\nfunc TestRetry_SuccessOnSecondAttempt(t *testing.T) {}\nfunc TestRetry_FailAfterAllAttempts(t *testing.T) {}\nfunc TestRetry_NoRetryOnAuthError(t *testing.T) {}\nfunc TestBackoff_Calculation(t *testing.T) {}\n```\n\n## Exec Mocking\nUse testify/mock or a custom exec wrapper:\n```go\ntype execRunner interface {\n    Run(name string, args ...string) ([]byte, error)\n}\n```\n\n## Acceptance Criteria\n- [ ] All client methods tested\n- [ ] Parser edge cases covered\n- [ ] Retry logic thoroughly tested\n- [ ] Error classification tested\n- [ ] Coverage \u003e 90%\n\n## Part of Epic\nGitHub CLI Integration (prt-749)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-19T10:41:29.746471-05:00","updated_at":"2025-12-19T10:41:29.746471-05:00","dependencies":[{"issue_id":"prt-s8o","depends_on_id":"prt-ln4","type":"blocks","created_at":"2025-12-19T10:49:19.578964-05:00","created_by":"daemon"},{"issue_id":"prt-s8o","depends_on_id":"prt-749","type":"parent-child","created_at":"2025-12-19T11:01:19.395583-05:00","created_by":"daemon"}]}
{"id":"prt-szp","title":"Implement PR list JSON parsing","description":"## Task\nParse the JSON output from `gh pr list` into PR model structs.\n\n## File: internal/github/parser.go\n\n## gh Command\n```bash\ngh pr list --json number,title,url,author,state,isDraft,createdAt,baseRefName,headRefName,statusCheckRollup,reviewRequests,assignees,reviews --state open\n```\n\n## JSON Structure\n```json\n[{\n  \"number\": 402,\n  \"title\": \"Feature: Auth\",\n  \"url\": \"https://github.com/org/repo/pull/402\",\n  \"author\": { \"login\": \"jdoe\" },\n  \"state\": \"OPEN\",\n  \"isDraft\": false,\n  \"createdAt\": \"2024-12-15T10:30:00Z\",\n  \"baseRefName\": \"main\",\n  \"headRefName\": \"feature-auth\",\n  \"statusCheckRollup\": [\n    { \"context\": \"ci/build\", \"state\": \"SUCCESS\" },\n    { \"context\": \"ci/test\", \"state\": \"FAILURE\" }\n  ],\n  \"reviewRequests\": [{ \"login\": \"reviewer1\" }],\n  \"assignees\": [{ \"login\": \"assignee1\" }],\n  \"reviews\": [{\n    \"author\": { \"login\": \"reviewer1\" },\n    \"state\": \"APPROVED\",\n    \"submittedAt\": \"2024-12-16T14:00:00Z\"\n  }]\n}]\n```\n\n## Parser Implementation\n```go\ntype ghPR struct {\n    Number      int    `json:\"number\"`\n    Title       string `json:\"title\"`\n    URL         string `json:\"url\"`\n    Author      struct{ Login string } `json:\"author\"`\n    State       string `json:\"state\"`\n    IsDraft     bool   `json:\"isDraft\"`\n    CreatedAt   string `json:\"createdAt\"`\n    BaseRefName string `json:\"baseRefName\"`\n    HeadRefName string `json:\"headRefName\"`\n    StatusCheckRollup []struct {\n        Context string `json:\"context\"`\n        State   string `json:\"state\"`\n    } `json:\"statusCheckRollup\"`\n    ReviewRequests []struct{ Login string } `json:\"reviewRequests\"`\n    Assignees      []struct{ Login string } `json:\"assignees\"`\n    Reviews []struct {\n        Author      struct{ Login string } `json:\"author\"`\n        State       string `json:\"state\"`\n        SubmittedAt string `json:\"submittedAt\"`\n    } `json:\"reviews\"`\n}\n\nfunc ParsePRList(data []byte) ([]*models.PR, error) {\n    var ghPRs []ghPR\n    if err := json.Unmarshal(data, \u0026ghPRs); err != nil {\n        return nil, fmt.Errorf(\"failed to parse PR list: %w\", err)\n    }\n    \n    prs := make([]*models.PR, 0, len(ghPRs))\n    for _, gpr := range ghPRs {\n        pr, err := convertPR(gpr)\n        if err != nil {\n            return nil, err\n        }\n        prs = append(prs, pr)\n    }\n    \n    return prs, nil\n}\n\nfunc convertPR(gpr ghPR) (*models.PR, error) {\n    createdAt, err := time.Parse(time.RFC3339, gpr.CreatedAt)\n    if err != nil {\n        return nil, fmt.Errorf(\"invalid createdAt: %w\", err)\n    }\n    \n    // Convert reviewRequests\n    reviewRequests := make([]string, len(gpr.ReviewRequests))\n    for i, rr := range gpr.ReviewRequests {\n        reviewRequests[i] = rr.Login\n    }\n    \n    // Convert assignees\n    assignees := make([]string, len(gpr.Assignees))\n    for i, a := range gpr.Assignees {\n        assignees[i] = a.Login\n    }\n    \n    // Convert reviews\n    reviews := make([]models.Review, len(gpr.Reviews))\n    for i, r := range gpr.Reviews {\n        submitted, _ := time.Parse(time.RFC3339, r.SubmittedAt)\n        reviews[i] = models.Review{\n            Author:    r.Author.Login,\n            State:     models.ReviewState(r.State),\n            Submitted: submitted,\n        }\n    }\n    \n    return \u0026models.PR{\n        Number:         gpr.Number,\n        Title:          gpr.Title,\n        URL:            gpr.URL,\n        Author:         gpr.Author.Login,\n        State:          models.PRState(gpr.State),\n        IsDraft:        gpr.IsDraft,\n        BaseBranch:     gpr.BaseRefName,\n        HeadBranch:     gpr.HeadRefName,\n        CreatedAt:      createdAt,\n        CIStatus:       computeCIStatus(gpr.StatusCheckRollup),\n        ReviewRequests: reviewRequests,\n        Assignees:      assignees,\n        Reviews:        reviews,\n    }, nil\n}\n\nfunc computeCIStatus(checks []struct{ Context, State string }) models.CIStatus {\n    if len(checks) == 0 {\n        return models.CIStatusNone\n    }\n    \n    hasFailing := false\n    hasPending := false\n    \n    for _, check := range checks {\n        switch check.State {\n        case \"FAILURE\", \"ERROR\":\n            hasFailing = true\n        case \"PENDING\", \"EXPECTED\", \"QUEUED\":\n            hasPending = true\n        }\n    }\n    \n    if hasFailing {\n        return models.CIStatusFailing\n    }\n    if hasPending {\n        return models.CIStatusPending\n    }\n    return models.CIStatusPassing\n}\n```\n\n## Acceptance Criteria\n- [ ] Parses all fields correctly\n- [ ] Handles nested objects (author.login)\n- [ ] Computes CI status from checks\n- [ ] Handles empty arrays\n- [ ] Unit tests with sample JSON\n\n## Part of Epic\nGitHub CLI Integration (prt-749)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-19T10:41:18.695636-05:00","updated_at":"2025-12-19T10:41:18.695636-05:00","dependencies":[{"issue_id":"prt-szp","depends_on_id":"prt-jn5","type":"blocks","created_at":"2025-12-19T10:49:07.198989-05:00","created_by":"daemon"},{"issue_id":"prt-szp","depends_on_id":"prt-749","type":"parent-child","created_at":"2025-12-19T11:01:16.884832-05:00","created_by":"daemon"}]}
{"id":"prt-tsv","title":"Implement concurrent PR fetching with goroutines","description":"## Task\nFetch PRs from all discovered repositories concurrently.\n\n## File: internal/github/orchestrator.go\n\n## Implementation\n```go\ntype FetchProgress func(done, total int, repo *models.Repository)\n\nfunc FetchAllPRs(repos []*models.Repository, client Client, progress FetchProgress) {\n    if len(repos) == 0 {\n        return\n    }\n    \n    var wg sync.WaitGroup\n    results := make(chan *models.Repository, len(repos))\n    \n    // Semaphore to limit concurrency (avoid rate limiting)\n    sem := make(chan struct{}, 10) // Max 10 concurrent requests\n    \n    for _, repo := range repos {\n        wg.Add(1)\n        go func(r *models.Repository) {\n            defer wg.Done()\n            \n            sem \u003c- struct{}{}        // Acquire\n            defer func() { \u003c-sem }() // Release\n            \n            prs, err := client.ListPRs(r.Path)\n            if err != nil {\n                r.ScanError = err\n                r.ScanStatus = models.ScanStatusError\n            } else if len(prs) == 0 {\n                r.ScanStatus = models.ScanStatusNoPRs\n            } else {\n                r.PRs = prs\n                r.ScanStatus = models.ScanStatusSuccess\n            }\n            \n            results \u003c- r\n        }(repo)\n    }\n    \n    // Collect results and call progress\n    go func() {\n        wg.Wait()\n        close(results)\n    }()\n    \n    done := 0\n    total := len(repos)\n    for repo := range results {\n        done++\n        if progress != nil {\n            progress(done, total, repo)\n        }\n    }\n}\n```\n\n## Why Semaphore?\nWithout limiting concurrency:\n- 50 repos = 50 simultaneous HTTP requests\n- Could hit GitHub rate limits\n- Could overwhelm network\n- 10 concurrent is a safe default\n\n## Progress Callback\nCalled after each repo completes:\n```go\nFetchAllPRs(repos, client, func(done, total int, repo *Repository) {\n    fmt.Printf(\"\\r%d/%d repos scanned\", done, total)\n})\n```\n\n## Partial Failure Handling\n- Individual repo errors stored in repo.ScanError\n- Other repos continue fetching\n- Caller can inspect ReposWithErrors later\n\n## Acceptance Criteria\n- [ ] Concurrent fetching (verify via timing)\n- [ ] Semaphore limits concurrency\n- [ ] Progress callback invoked\n- [ ] Partial failures handled\n- [ ] Thread-safe (no data races)\n\n## Part of Epic\nConcurrent PR Fetching \u0026 Orchestration (prt-e4a)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-19T10:43:56.47146-05:00","updated_at":"2025-12-19T10:43:56.47146-05:00","dependencies":[{"issue_id":"prt-tsv","depends_on_id":"prt-ln4","type":"blocks","created_at":"2025-12-19T10:49:44.167931-05:00","created_by":"daemon"},{"issue_id":"prt-tsv","depends_on_id":"prt-ua5","type":"blocks","created_at":"2025-12-19T10:49:44.762717-05:00","created_by":"daemon"},{"issue_id":"prt-tsv","depends_on_id":"prt-e4a","type":"parent-child","created_at":"2025-12-19T11:01:35.520858-05:00","created_by":"daemon"}]}
{"id":"prt-ua5","title":"Implement directory walker with depth control","description":"## Task\nImplement the core directory walking logic with configurable depth limits.\n\n## File: internal/scanner/scanner.go\n\n## Scanner Interface\n```go\ntype Scanner interface {\n    Scan(cfg *config.Config) ([]*models.Repository, error)\n}\n\ntype scanner struct {\n    maxDepth    int\n    includeGlob []glob.Glob\n}\n\nfunc NewScanner(maxDepth int, includePatterns []string) (Scanner, error) {\n    // Compile glob patterns\n    globs := make([]glob.Glob, 0, len(includePatterns))\n    for _, pattern := range includePatterns {\n        g, err := glob.Compile(pattern)\n        if err != nil {\n            return nil, fmt.Errorf(\"invalid pattern %q: %w\", pattern, err)\n        }\n        globs = append(globs, g)\n    }\n    return \u0026scanner{maxDepth: maxDepth, includeGlob: globs}, nil\n}\n```\n\n## Walk Implementation\n```go\nfunc (s *scanner) Scan(cfg *config.Config) ([]*models.Repository, error) {\n    var repos []*models.Repository\n    seen := make(map[string]bool) // Prevent duplicates\n    \n    for _, searchPath := range cfg.SearchPaths {\n        err := filepath.WalkDir(searchPath, func(path string, d fs.DirEntry, err error) error {\n            // Handle access errors gracefully\n            if err != nil {\n                return nil // Skip inaccessible, continue\n            }\n            \n            // Check depth relative to search path\n            depth := countDepth(searchPath, path)\n            if depth \u003e s.maxDepth {\n                if d.IsDir() {\n                    return filepath.SkipDir\n                }\n                return nil\n            }\n            \n            // Skip non-directories\n            if !d.IsDir() {\n                return nil\n            }\n            \n            // Skip symlinks\n            if d.Type()\u0026fs.ModeSymlink != 0 {\n                return filepath.SkipDir\n            }\n            \n            // Found .git directory?\n            if d.Name() == \".git\" {\n                repoPath := filepath.Dir(path)\n                if !seen[repoPath] {\n                    seen[repoPath] = true\n                    repo, err := s.inspectRepo(repoPath)\n                    if err == nil \u0026\u0026 s.matchesIncludePatterns(repo.Name) {\n                        repos = append(repos, repo)\n                    }\n                }\n                return filepath.SkipDir // Don't descend into .git\n            }\n            \n            return nil\n        })\n        \n        if err != nil {\n            return nil, fmt.Errorf(\"error scanning %s: %w\", searchPath, err)\n        }\n    }\n    \n    return repos, nil\n}\n\nfunc countDepth(base, path string) int {\n    rel, err := filepath.Rel(base, path)\n    if err != nil {\n        return 0\n    }\n    if rel == \".\" {\n        return 0\n    }\n    return strings.Count(rel, string(os.PathSeparator)) + 1\n}\n```\n\n## Depth Calculation\nWith maxDepth=3 and base=/Users/jdoe/code:\n- /Users/jdoe/code -\u003e depth 0\n- /Users/jdoe/code/work -\u003e depth 1\n- /Users/jdoe/code/work/project -\u003e depth 2\n- /Users/jdoe/code/work/project/sub -\u003e depth 3 (at limit)\n- /Users/jdoe/code/work/project/sub/x -\u003e depth 4 (skip)\n\n## Acceptance Criteria\n- [ ] Walks all configured search paths\n- [ ] Respects depth limit correctly\n- [ ] Skips symlinks\n- [ ] Handles permission errors gracefully\n- [ ] Doesn't return duplicates\n\n## Part of Epic\nRepository Scanner (prt-bhq)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-19T10:42:30.100922-05:00","updated_at":"2025-12-19T10:42:30.100922-05:00","dependencies":[{"issue_id":"prt-ua5","depends_on_id":"prt-du2","type":"blocks","created_at":"2025-12-19T10:49:32.632425-05:00","created_by":"daemon"},{"issue_id":"prt-ua5","depends_on_id":"prt-5eu","type":"blocks","created_at":"2025-12-19T10:49:33.170737-05:00","created_by":"daemon"},{"issue_id":"prt-ua5","depends_on_id":"prt-bhq","type":"parent-child","created_at":"2025-12-19T11:01:33.050015-05:00","created_by":"daemon"},{"issue_id":"prt-ua5","depends_on_id":"prt-ee6","type":"blocks","created_at":"2025-12-19T11:08:54.522412-05:00","created_by":"daemon"},{"issue_id":"prt-ua5","depends_on_id":"prt-62e","type":"blocks","created_at":"2025-12-19T11:08:56.4181-05:00","created_by":"daemon"}]}
{"id":"prt-ukh","title":"Create Makefile with build targets","description":"## Task\nCreate a Makefile with standard Go project targets.\n\n## Targets Required\n```makefile\nVERSION ?= $(shell git describe --tags --always --dirty)\nLDFLAGS = -ldflags \"-X main.version=$(VERSION)\"\n\nbuild:           # Build binary to bin/prt\ntest:            # Run go test ./...\ntest-coverage:   # Run tests with coverage\nclean:           # rm -rf bin/ coverage.out\ninstall:         # Copy to /usr/local/bin\nlint:            # Run golangci-lint (if available)\nfmt:             # Run go fmt ./...\n```\n\n## Version Embedding\nThe VERSION variable captures git tag/commit info and embeds it into the binary via ldflags. This allows `prt --version` to show meaningful version info.\n\n## Acceptance Criteria\n- [ ] `make build` produces bin/prt\n- [ ] `make test` runs tests\n- [ ] `make clean` removes artifacts\n- [ ] VERSION correctly extracted from git\n\n## Part of Epic\nProject Foundation \u0026 Scaffolding (prt-ai4)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-19T10:37:13.35962-05:00","updated_at":"2025-12-19T10:37:13.35962-05:00","dependencies":[{"issue_id":"prt-ukh","depends_on_id":"prt-mt5","type":"blocks","created_at":"2025-12-19T10:47:57.968411-05:00","created_by":"daemon"},{"issue_id":"prt-ukh","depends_on_id":"prt-ai4","type":"parent-child","created_at":"2025-12-19T11:00:13.38619-05:00","created_by":"daemon"}]}
{"id":"prt-um6","title":"Write config unit tests","description":"## Task\nWrite comprehensive unit tests for the configuration system.\n\n## File: internal/config/config_test.go\n\n## Test Cases\n\n### Load Tests\n```go\nfunc TestLoad_WithValidFile(t *testing.T) {\n    // Create temp config file, load it, verify values\n}\n\nfunc TestLoad_MissingFile(t *testing.T) {\n    // Should return defaults, not error\n}\n\nfunc TestLoad_InvalidYAML(t *testing.T) {\n    // Should return error with helpful message\n}\n\nfunc TestLoad_FlagOverrides(t *testing.T) {\n    // CLI flags should override config file\n}\n\nfunc TestLoad_EnvOverrides(t *testing.T) {\n    // PRT_* env vars should work\n}\n\nfunc TestLoad_Precedence(t *testing.T) {\n    // Flag \u003e Env \u003e File \u003e Default\n}\n```\n\n### Validation Tests\n```go\nfunc TestValidate_MissingUsername(t *testing.T) {}\nfunc TestValidate_NoSearchPaths(t *testing.T) {}\nfunc TestValidate_InvalidSearchPath(t *testing.T) {}\nfunc TestValidate_InvalidGroupBy(t *testing.T) {}\nfunc TestValidate_InvalidSort(t *testing.T) {}\nfunc TestValidate_InvalidScanDepth(t *testing.T) {}\nfunc TestValidate_ValidConfig(t *testing.T) {}\n```\n\n### Path Expansion Tests\n```go\nfunc TestExpandPaths_Tilde(t *testing.T) {\n    // ~/foo -\u003e /home/user/foo\n}\n\nfunc TestExpandPaths_Absolute(t *testing.T) {\n    // /foo -\u003e /foo (unchanged)\n}\n\nfunc TestExpandPaths_Empty(t *testing.T) {\n    // Empty slice -\u003e empty slice\n}\n```\n\n### Template Tests\n```go\nfunc TestGenerateConfigFile_ValidYAML(t *testing.T) {\n    // Generated content should parse as valid YAML\n}\n\nfunc TestGenerateConfigFile_ContainsValues(t *testing.T) {\n    // Values should appear in output\n}\n```\n\n## Test Utilities\n```go\nfunc createTempConfig(t *testing.T, content string) string {\n    t.Helper()\n    dir := t.TempDir()\n    path := filepath.Join(dir, \"config.yaml\")\n    os.WriteFile(path, []byte(content), 0644)\n    return path\n}\n```\n\n## Acceptance Criteria\n- [ ] All Load scenarios tested\n- [ ] All Validation rules tested\n- [ ] Path expansion tested\n- [ ] Template generation tested\n- [ ] Coverage \u003e 90%\n\n## Part of Epic\nConfiguration System (prt-v3f)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-19T10:39:55.482282-05:00","updated_at":"2025-12-19T10:39:55.482282-05:00","dependencies":[{"issue_id":"prt-um6","depends_on_id":"prt-e31","type":"blocks","created_at":"2025-12-19T10:48:57.985019-05:00","created_by":"daemon"},{"issue_id":"prt-um6","depends_on_id":"prt-755","type":"blocks","created_at":"2025-12-19T10:48:58.616539-05:00","created_by":"daemon"},{"issue_id":"prt-um6","depends_on_id":"prt-v3f","type":"parent-child","created_at":"2025-12-19T11:01:06.946963-05:00","created_by":"daemon"},{"issue_id":"prt-um6","depends_on_id":"prt-0ch","type":"blocks","created_at":"2025-12-19T11:09:05.027343-05:00","created_by":"daemon"}]}
{"id":"prt-uym","title":"Implement PR categorization logic","description":"## Task\nCategorize PRs into four buckets based on user's relationship to them.\n\n## File: internal/categorizer/categorizer.go\n\n## Categories\n1. **My PRs**: Authored by current user\n2. **Needs My Attention**: Review requested OR assigned to me (and not yet approved)\n3. **Team PRs**: Authored by team members\n4. **Other PRs**: Everyone else (including bots)\n\n## Implementation\n```go\ntype Categorizer interface {\n    Categorize(repos []*models.Repository, cfg *config.Config, username string) *models.ScanResult\n}\n\nfunc NewCategorizer() Categorizer {\n    return \u0026categorizer{}\n}\n\nfunc (c *categorizer) Categorize(repos []*models.Repository, cfg *config.Config, username string) *models.ScanResult {\n    result := \u0026models.ScanResult{\n        MyPRs:            []*models.PR{},\n        NeedsMyAttention: []*models.PR{},\n        TeamPRs:          []*models.PR{},\n        OtherPRs:         []*models.PR{},\n        ReposWithPRs:     []*models.Repository{},\n        ReposWithoutPRs:  []*models.Repository{},\n        ReposWithErrors:  []*models.Repository{},\n        Stacks:           make(map[string]*models.Stack),\n        Username:         username,\n    }\n    \n    teamSet := toSet(cfg.TeamMembers)\n    botSet := toSet(cfg.Bots)\n    \n    for _, repo := range repos {\n        // Handle repos with errors\n        if repo.ScanError \\!= nil {\n            result.ReposWithErrors = append(result.ReposWithErrors, repo)\n            continue\n        }\n        \n        // Handle repos with no PRs\n        if \\!repo.HasPRs() {\n            result.ReposWithoutPRs = append(result.ReposWithoutPRs, repo)\n            continue\n        }\n        \n        result.ReposWithPRs = append(result.ReposWithPRs, repo)\n        result.TotalPRsFound += len(repo.PRs)\n        \n        // Detect stacks for this repo\n        result.Stacks[repo.Name] = stacks.DetectStacks(repo.PRs)\n        \n        // Categorize each PR\n        for _, pr := range repo.PRs {\n            pr.RepoName = repo.Name\n            pr.RepoPath = repo.Path\n            \n            // Compute user-specific fields\n            pr.IsReviewRequestedFromMe = contains(pr.ReviewRequests, username)\n            pr.IsAssignedToMe = contains(pr.Assignees, username)\n            pr.MyReviewStatus = findMyReviewStatus(pr.Reviews, username)\n            \n            // Categorize\n            c.categorizePR(pr, username, teamSet, botSet, result)\n        }\n    }\n    \n    result.TotalReposScanned = len(repos)\n    \n    return result\n}\n\nfunc (c *categorizer) categorizePR(pr *models.PR, username string, teamSet, botSet map[string]bool, result *models.ScanResult) {\n    switch {\n    case pr.Author == username:\n        // My PR\n        result.MyPRs = append(result.MyPRs, pr)\n        \n    case pr.IsReviewRequestedFromMe || pr.IsAssignedToMe:\n        // Needs my attention (unless already approved)\n        if pr.MyReviewStatus \\!= models.ReviewStateApproved {\n            result.NeedsMyAttention = append(result.NeedsMyAttention, pr)\n        } else {\n            // I approved it, treat based on author\n            if teamSet[pr.Author] {\n                result.TeamPRs = append(result.TeamPRs, pr)\n            } else {\n                result.OtherPRs = append(result.OtherPRs, pr)\n            }\n        }\n        \n    case teamSet[pr.Author]:\n        result.TeamPRs = append(result.TeamPRs, pr)\n        \n    case botSet[pr.Author]:\n        result.OtherPRs = append(result.OtherPRs, pr)\n        \n    default:\n        result.OtherPRs = append(result.OtherPRs, pr)\n    }\n}\n```\n\n## Helper Functions\n```go\nfunc toSet(slice []string) map[string]bool {\n    set := make(map[string]bool)\n    for _, s := range slice {\n        set[s] = true\n    }\n    return set\n}\n\nfunc contains(slice []string, item string) bool {\n    for _, s := range slice {\n        if s == item {\n            return true\n        }\n    }\n    return false\n}\n\nfunc findMyReviewStatus(reviews []models.Review, username string) models.ReviewState {\n    var latest *models.Review\n    for i := range reviews {\n        r := \u0026reviews[i]\n        if r.Author == username {\n            if latest == nil || r.Submitted.After(latest.Submitted) {\n                latest = r\n            }\n        }\n    }\n    if latest == nil {\n        return models.ReviewStateNone\n    }\n    return latest.State\n}\n```\n\n## Acceptance Criteria\n- [ ] My PRs detected correctly\n- [ ] Review requests categorized as \"Needs Attention\"\n- [ ] Assigned PRs categorized as \"Needs Attention\"\n- [ ] Approved PRs don't show in \"Needs Attention\"\n- [ ] Team members categorized correctly\n- [ ] Bots categorized as \"Other\"\n- [ ] Unit tests for all rules\n\n## Part of Epic\nPR Categorization (prt-zsl)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-19T10:44:00.645498-05:00","updated_at":"2025-12-19T10:44:00.645498-05:00","dependencies":[{"issue_id":"prt-uym","depends_on_id":"prt-clj","type":"blocks","created_at":"2025-12-19T10:49:55.379613-05:00","created_by":"daemon"},{"issue_id":"prt-uym","depends_on_id":"prt-5eu","type":"blocks","created_at":"2025-12-19T10:49:55.922925-05:00","created_by":"daemon"},{"issue_id":"prt-uym","depends_on_id":"prt-zsl","type":"parent-child","created_at":"2025-12-19T11:01:37.99091-05:00","created_by":"daemon"}]}
{"id":"prt-v3f","title":"Configuration System","description":"## Overview\nImplement the YAML-based configuration system using Viper. Config controls repository paths, team members, bot lists, display preferences, and more.\n\n## Why This Matters\nConfiguration is the bridge between PRT and the user's environment. It must be:\n- Easy to create (first-run wizard)\n- Easy to edit (YAML with comments)\n- Flexible (CLI flags override config)\n- Discoverable (sensible defaults)\n\n## Config Location\n`~/.prt/config.yaml`\n\n## Config Schema\n```yaml\ngithub_username: \"\"        # Auto-detected if empty\nteam_members: []           # GitHub usernames for team highlighting\nsearch_paths: []           # Where to look for repos\ninclude_repos: []          # Glob patterns (empty = all)\nscan_depth: 3              # Max directory depth\nbots: [...]                # Known bot accounts (pre-populated)\ndefault_group_by: project  # project | author\ndefault_sort: oldest       # oldest | newest\nshow_branch_name: true\nshow_icons: true\n```\n\n## Precedence (highest to lowest)\n1. CLI flags (`--path`, `--filter`, etc.)\n2. Environment variables (`PRT_GITHUB_USERNAME`, etc.)\n3. Config file\n4. Hardcoded defaults\n\n## Components\n- `internal/config/types.go`: Config struct with yaml/mapstructure tags\n- `internal/config/defaults.go`: DefaultConfig, known bots list, path helpers\n- `internal/config/config.go`: Load(), Save(), Validate() functions\n\n## Known Bots (Pre-populated)\ndependabot[bot], renovate[bot], github-actions[bot], codecov[bot], semantic-release-bot, greenkeeper[bot], snyk-bot, imgbot[bot], allcontributors[bot], mergify[bot], kodiakhq[bot], stale[bot]\n\n## Validation Rules\n- At least one search_path must be set (or wizard triggered)\n- github_username must be set or auto-detectable\n- scan_depth must be \u003e= 1\n\n## Acceptance Criteria\n- [ ] Config loads from YAML file\n- [ ] Missing file triggers config creation (not error)\n- [ ] CLI flags override config values\n- [ ] Environment variables work (PRT_* prefix)\n- [ ] Validation catches invalid configs\n- [ ] Unit tests cover all precedence scenarios\n\n## Considerations\n- Use viper's SetConfigType(\"yaml\") for explicit format\n- Expand ~ in paths before use\n- Config validation should give helpful error messages","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-19T10:32:20.237399-05:00","updated_at":"2025-12-19T11:02:20.069704-05:00"}
{"id":"prt-x7j","title":"Stack Detection Algorithm","description":"## Overview\nDetect 'stacked PRs' - PRs that depend on other PRs. This is a key differentiator for PRT, helping users understand which PRs are blocked and which are ready to merge.\n\n## What Are Stacked PRs?\nWhen working on related changes, developers often create a 'stack' of PRs:\n1. PR_A: base feature (targets main)\n2. PR_B: enhancement (targets PR_A's branch)\n3. PR_C: tests (targets PR_B's branch)\n\nPR_C depends on PR_B, which depends on PR_A. PR_B and PR_C are 'blocked' until their parents merge.\n\n## Detection Algorithm\n```\nFor each PR in the repo:\n  If PR_X.baseBranch == PR_Y.headBranch:\n    PR_X is a child of PR_Y\n    PR_Y is the parent of PR_X\n```\n\nExample:\n- PR_A: feature-auth -\u003e main\n- PR_B: feature-auth-tests -\u003e feature-auth\n- PR_B's base (feature-auth) == PR_A's head (feature-auth)\n- Therefore: PR_B is child of PR_A\n\n## Data Structures\n\n### StackNode\n```go\ntype StackNode struct {\n    PR       *PR\n    Parent   *StackNode\n    Children []*StackNode\n    Depth    int           // 0 = root\n    IsOrphan bool          // Parent was merged\n}\n```\n\n### Stack\n```go\ntype Stack struct {\n    Roots    []*StackNode  // PRs with no parent in set\n    AllNodes []*StackNode  // Flattened for iteration\n}\n```\n\n## Orphan Detection\nWhen a parent PR merges, its children become 'orphans'. They still target a branch, but that branch is now part of main. The child should be rebased.\n\nDetection: If a PR's base branch exists but no PR has it as head, check if it's a common branch (main, master, develop). If not, it might be an orphan.\n\n## Visual Representation\nStacked PRs should be displayed as a tree:\n```\n‚îú‚îÄ‚îÄ #402 Feature: Auth (targets main)\n‚îÇ   ‚îî‚îÄ‚îÄ #405 Tests for Auth (blocked, targets #402's branch)\n```\n\nChild PRs should be visually dimmed/grayed to indicate blocked status.\n\n## Components\n- `internal/stacks/detector.go`: DetectStacks(prs []*PR) *Stack\n- `internal/stacks/builder.go`: Tree building helpers\n\n## Acceptance Criteria\n- [ ] Detects parent-child relationships correctly\n- [ ] Builds proper tree structure\n- [ ] Handles multiple independent stacks in same repo\n- [ ] Handles deep stacks (3+ levels)\n- [ ] Detects orphaned children\n- [ ] Calculates depth correctly\n- [ ] Unit tests with various stack scenarios\n\n## Test Scenarios\n1. No stacks (all PRs target main)\n2. Simple 2-level stack\n3. Deep 3+ level stack\n4. Multiple independent stacks\n5. Diamond pattern (two PRs target same parent)\n6. Orphaned child (parent merged)\n7. Single PR (no relationships)","status":"open","priority":2,"issue_type":"epic","created_at":"2025-12-19T10:34:04.822499-05:00","updated_at":"2025-12-19T11:02:20.072582-05:00"}
{"id":"prt-zib","title":"Data Models","description":"## Overview\nDefine the core domain types that represent PRs, Repositories, Stacks, and aggregated Results. These are pure data structures with no business logic, serving as the lingua franca between all other packages.\n\n## Why This Matters\nClean separation of data from behavior. All packages depend on models, but models depend on nothing. This creates a stable foundation that rarely changes.\n\n## Models to Implement\n\n### PR Model (`internal/models/pr.go`)\n- Identity: Number, Title, URL\n- Authorship: Author\n- State: PRState (OPEN/DRAFT/MERGED/CLOSED), IsDraft\n- Branches: BaseBranch, HeadBranch\n- Timestamps: CreatedAt\n- CI Status: CIStatus (passing/failing/pending/none)\n- Reviews: ReviewRequests, Assignees, Reviews[]\n- Computed: IsReviewRequestedFromMe, IsAssignedToMe, MyReviewStatus\n- Context: RepoName, RepoPath\n- Helpers: Age(), AgeString(), EffectiveState()\n\n### Repository Model (`internal/models/repo.go`)\n- Name, Path, RemoteURL, Owner\n- PRs slice\n- ScanError, ScanStatus\n- Helpers: FullName(), HasPRs()\n\n### Stack Model (`internal/models/stack.go`)\n- StackNode: PR, Parent, Children, Depth, IsOrphan\n- Stack: Roots, AllNodes\n- Helpers: IsBlocked(), GetRoot()\n\n### Result Model (`internal/models/result.go`)\n- Categorized PRs: MyPRs, NeedsMyAttention, TeamPRs, OtherPRs\n- Repos: ReposWithPRs, ReposWithoutPRs, ReposWithErrors\n- Stacks map\n- Metadata: TotalReposScanned, TotalPRsFound, ScanDuration, Username\n\n## Design Principles\n- Pure data structures - no I/O, no side effects\n- JSON struct tags for serialization\n- Enums as typed strings for clarity\n- Helper methods for common computations\n\n## Acceptance Criteria\n- [ ] All model types compile\n- [ ] JSON serialization works correctly\n- [ ] Helper methods have unit tests\n- [ ] No circular dependencies\n\n## Testing Notes\nModels are pure logic - easy to test. Write table-driven tests for helpers like Age() and AgeString().","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-19T10:32:19.032302-05:00","updated_at":"2025-12-19T11:02:20.068866-05:00"}
{"id":"prt-zsl","title":"PR Categorization","description":"## Overview\nCategorize PRs based on the user's relationship to them. This is the core intelligence of PRT - showing users what needs their attention first.\n\n## Categories (in priority order)\n\n### 1. My PRs\nPRs authored by the current user. These are 'outgoing' - work you're waiting for others to review.\n\nDetection: `pr.Author == config.GitHubUsername`\n\n### 2. Needs My Attention  \nPRs where you're explicitly requested to act. These are urgent 'incoming' work.\n\nDetection:\n- Review requested from you: `pr.ReviewRequests.contains(username)`\n- Assigned to you: `pr.Assignees.contains(username)`\n- AND you haven't already approved: `myReviewStatus != APPROVED`\n\n### 3. Team PRs\nPRs from your configured team members. Important to be aware of, but not urgent.\n\nDetection: `config.TeamMembers.contains(pr.Author)`\n\n### 4. Other PRs\nEverything else - external contributors, bots, etc.\n\nDetection: Falls through when nothing else matches.\n\nSpecial handling for bots:\n- Match against `config.Bots` list\n- Display in 'Other' but potentially de-emphasized\n\n## Review Status Computation\nFor each PR, compute the user's review status:\n1. Find all reviews from user\n2. Sort by submittedAt descending\n3. Return most recent review's state\n4. If no reviews, return NONE\n\nStates: NONE, APPROVED, CHANGES_REQUESTED, COMMENTED, PENDING, DISMISSED\n\n## Sorting\nWithin each category, sort by:\n- `oldest`: Oldest PRs first (default) - highlights stale items\n- `newest`: Newest PRs first\n\n## Edge Cases\n- User is both author AND reviewer requested -\u003e categorize as 'My PRs'\n- User approved but still assigned -\u003e show in 'Team PRs' (not needs attention)\n- Bot from team member's automation -\u003e treat as bot (check bots list first)\n\n## Components\n- `internal/categorizer/categorizer.go`: Main categorization logic\n- `internal/categorizer/sorter.go`: Sorting helpers\n\n## Acceptance Criteria\n- [ ] My PRs detected correctly\n- [ ] Review requests detected\n- [ ] Assignments detected\n- [ ] Approved PRs excluded from 'Needs Attention'\n- [ ] Team members categorized correctly\n- [ ] Bots categorized as 'Other'\n- [ ] Sorting works both directions\n- [ ] Edge cases handled\n- [ ] Unit tests for all rules\n\n## Design Decision\nCategories are computed fresh each run (no caching). PRs change frequently - a stale category would be worse than useless.","status":"open","priority":2,"issue_type":"epic","created_at":"2025-12-19T10:34:05.842574-05:00","updated_at":"2025-12-19T11:02:20.073314-05:00"}
